{"email":"jan@gmail.com","level":"info","message":"Logging in user:","timestamp":"2024-11-20T10:32:57.417Z"}
{"level":"error","message":"Error during login: Invalid password","stack":"Error: Invalid password\n    at UserUseCase.loginUser (C:\\Users\\rinis\\Desktop\\New folder (2)\\escribir-backend\\dist\\useCases\\UserUseCase.js:145:19)\n    at async UserController.login (C:\\Users\\rinis\\Desktop\\New folder (2)\\escribir-backend\\dist\\providers\\controllers\\userController.js:127:57)","timestamp":"2024-11-20T10:32:57.474Z"}
{"email":"jan@gmail.com","level":"info","message":"Logging in user:","timestamp":"2024-11-20T10:33:00.529Z"}
{"level":"error","message":"Error during login: Invalid password","stack":"Error: Invalid password\n    at UserUseCase.loginUser (C:\\Users\\rinis\\Desktop\\New folder (2)\\escribir-backend\\dist\\useCases\\UserUseCase.js:145:19)\n    at async UserController.login (C:\\Users\\rinis\\Desktop\\New folder (2)\\escribir-backend\\dist\\providers\\controllers\\userController.js:127:57)","timestamp":"2024-11-20T10:33:00.594Z"}
{"email":"jansiyajahan8@gmail.com","level":"info","message":"Logging in user:","timestamp":"2024-11-20T10:33:06.862Z"}
{"email":"jan@gmail.com","level":"info","message":"Logging in user:","timestamp":"2024-11-20T10:33:34.898Z"}
{"level":"error","message":"Error during login: Invalid password","stack":"Error: Invalid password\n    at UserUseCase.loginUser (C:\\Users\\rinis\\Desktop\\New folder (2)\\escribir-backend\\dist\\useCases\\UserUseCase.js:145:19)\n    at async UserController.login (C:\\Users\\rinis\\Desktop\\New folder (2)\\escribir-backend\\dist\\providers\\controllers\\userController.js:127:57)","timestamp":"2024-11-20T10:33:34.962Z"}
{"email":"jan@gmail.com","level":"info","message":"Logging in user:","timestamp":"2024-11-20T10:34:18.231Z"}
{"level":"error","message":"Error during login: Invalid password","stack":"Error: Invalid password\n    at UserUseCase.loginUser (C:\\Users\\rinis\\Desktop\\New folder (2)\\escribir-backend\\dist\\useCases\\UserUseCase.js:145:19)\n    at async UserController.login (C:\\Users\\rinis\\Desktop\\New folder (2)\\escribir-backend\\dist\\providers\\controllers\\userController.js:127:57)","timestamp":"2024-11-20T10:34:18.293Z"}
{"email":"jan@gmail.com","level":"info","message":"Logging in user:","timestamp":"2024-11-20T10:36:00.773Z"}
{"level":"error","message":"Error during login: Invalid password","stack":"Error: Invalid password\n    at UserUseCase.loginUser (C:\\Users\\rinis\\Desktop\\New folder (2)\\escribir-backend\\dist\\useCases\\UserUseCase.js:145:19)\n    at async UserController.login (C:\\Users\\rinis\\Desktop\\New folder (2)\\escribir-backend\\dist\\providers\\controllers\\userController.js:127:57)","timestamp":"2024-11-20T10:36:00.824Z"}
{"email":"jan@gmail.com","level":"info","message":"Logging in user:","timestamp":"2024-11-20T10:36:02.324Z"}
{"level":"error","message":"Error during login: Invalid password","stack":"Error: Invalid password\n    at UserUseCase.loginUser (C:\\Users\\rinis\\Desktop\\New folder (2)\\escribir-backend\\dist\\useCases\\UserUseCase.js:145:19)\n    at async UserController.login (C:\\Users\\rinis\\Desktop\\New folder (2)\\escribir-backend\\dist\\providers\\controllers\\userController.js:127:57)","timestamp":"2024-11-20T10:36:02.410Z"}
{"email":"jansiyajahan8@gmail.com","level":"info","message":"Logging in user:","timestamp":"2024-11-20T10:36:11.494Z"}
{"level":"info","message":"Fetching all blogs","timestamp":"2024-11-20T10:36:11.630Z"}
{"0":{"__v":0,"_id":"6728de448569245cc7ef2a74","author_id":{"_id":"6703c069d7012c3ddb50b644","image":"https://res.cloudinary.com/djfhotv8n/image/upload/v1728299835/Escribir_Profile_Images/ocyxece9pbagrcwn55zl.jpg","username":"Kunujuzz"},"comments":[],"content":"<p><img src=\"https://www.freecodecamp.org/news/content/images/2023/06/A9vQ.gif\" alt=\"An animated Pinky Promise between two people\" height=\"225\" width=\"400\"><em style=\"color: var(--gray85);\">Image Credit:&nbsp;</em><a href=\"https://gifer.com/en/Pxwc\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: var(--gray90); background-color: transparent;\"><em>https://gifer.com</em></a></p><p>A promise is an assurance or guarantee that something will happen in the future. A person can promise another person a specific outcome or result. Promises are not limited to individuals, governments and organizations can also make promises. You have probably made a promise before.</p><p>With this assurance (promise) comes two possible outcomes–either fulfillment or failure. A promise is tied to an outcome that will show it is fulfilled. If that outcome does not happen, then the promise failed. A promise at the end must have one of these results.</p><p>In JavaScript, a Promise is an&nbsp;<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_objects\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: var(--gray90); background-color: transparent;\">object</a>&nbsp;that will produce a single value some time in the future. If the promise is successful, it will produce a resolved value, but if something goes wrong then it will produce a reason why the promise failed. The possible outcomes here are similar to that of promises in real life.</p><p>JavaScript promises can be in one of three possible states. These states indicate the progress of the promise. They are:</p><ul><li><em style=\"color: var(--gray85);\">pending</em>: This is the default state of a defined promise</li><li><em style=\"color: var(--gray85);\">fulfilled</em>: This is the state of a successful promise</li><li><em style=\"color: var(--gray85);\">rejected</em>: This is the state of a failed promise</li></ul><p>A promise goes from&nbsp;<em style=\"color: var(--gray85);\">pending</em>&nbsp;to&nbsp;<em style=\"color: var(--gray85);\">fulfilled</em>, or from&nbsp;<em style=\"color: var(--gray85);\">pending</em>&nbsp;to&nbsp;<em style=\"color: var(--gray85);\">rejected—</em>‘fulfilled’ and ‘rejected’ indicate the end of a promise.</p><p>From now on, this article will refer to a 'promise' as the JavaScript object.</p><h2><strong>How to Create a Promise in JavaScript</strong></h2><p>To create a promise, you need to create an instance object using the&nbsp;<code>Promise</code>&nbsp;constructor function. The&nbsp;<code>Promise</code>&nbsp;constructor function takes in one parameter. That parameter is a function that defines when to resolve the new promise, and optionally when to reject it.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise = new Promise((resolve, reject) =&gt; {\r\n  // Condition to resolve or reject the promise\r\n});\r\n</pre><p>For example, assume you want a promise to resolve after a timeout of two seconds. You can achieve this by writing it into the parameter of the constructor function.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise = new Promise((resolve, reject) =&gt; {\r\n  setTimeout(() =&gt; resolve(\"Done!\"), 2000);\r\n});\r\n</pre><p>In promises,&nbsp;<code>resolve</code>&nbsp;is a function with an optional parameter representing the resolved value. Also,&nbsp;<code>reject</code>&nbsp;is a function with an optional parameter representing the reason why the promise failed. In the example above, the resolved value of the promise is the string&nbsp;<code>'Done!'</code>.</p><p>Here is yet another example showing how you can resolve or reject a promise based on the conditions you set. In this example, the outcome of the promise is based on a random number the program generates.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise = new Promise((resolve, reject) =&gt; {\r\n  const num = Math.random();\r\n  if (num &gt;= 0.5) {\r\n    resolve(\"Promise is fulfilled!\");\r\n  } else {\r\n    reject(\"Promise failed!\");\r\n  }\r\n});\r\n</pre><p>From these examples, you can see that you have control over when to resolve or reject your promise and can tie it to a certain condition. With that, you have learned how to create a promise in JavaScript.</p><h2><strong>How to Attach a Callback to a Promise</strong></h2><p>To create a callback for a promise, you need to use the&nbsp;<code>.then()</code>&nbsp;method. This method takes in two callback functions. The first function runs if the promise is resolved, while the second function runs if the promise is rejected.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise = new Promise((resolve, reject) =&gt; {\r\n  const num = Math.random();\r\n  if (num &gt;= 0.5) {\r\n    resolve(\"Promise is fulfilled!\");\r\n  } else {\r\n    reject(\"Promise failed!\");\r\n  }\r\n});\r\n\r\nfunction handleResolve(value) {\r\n  console.log(value);\r\n}\r\n\r\nfunction handleReject(reason) {\r\n  console.error(reason);\r\n}\r\n\r\npromise.then(handleResolve, handleReject);\r\n// Promise is fulfilled!\r\n// or\r\n// Promise failed!\r\n</pre><p>That is the way to handle the possible outcomes of your promise. Any unhandled errors in your promise will keep them in a rejected state at the end but handled errors makes the operation return a fulfilled promise.</p><p>It is possible to create an immediately resolved promise, and then attach a callback with the&nbsp;<code>.then()</code>&nbsp;method. You can also create an immediately rejected promise in the same way too.</p><pre class=\"ql-syntax\" spellcheck=\"false\">Promise.resolve(\"Successful\").then((result) =&gt; console.log(result));\r\n// Successful\r\n\r\nPromise.reject(\"Not successful\").then((result) =&gt; console.log(result));\r\n// Error: Uncaught (in promise)\r\n</pre><p>The error in the rejected promise is because you need to define a separate callback to handle a rejected promise.</p><pre class=\"ql-syntax\" spellcheck=\"false\">Promise.reject(\"Not successful\").then(\r\n  () =&gt; {\r\n    /*Empty Callback if Promise is fulfilled*/\r\n  },\r\n  (reason) =&gt; console.error(reason)\r\n);\r\n// Not Successful\r\n</pre><p>Now you have properly handled a rejected outcome.</p><p>Promises make it incredibly easy to chain asynchronous instructions. When you handle a promise with the&nbsp;<code style=\"color: var(--gray85);\"><strong>.then()</strong></code>&nbsp;method, the operation always returns another promise. By employing this approach, you can eliminate the previously mentioned 'Callback Pyramid of Doom'.</p><p>Consider the code that previously caused the pyramid structure:</p><pre class=\"ql-syntax\" spellcheck=\"false\">fetchResource(\r\n  url,\r\n  function (result) {\r\n    // Do something with the result\r\n    fetchResource(\r\n      newUrl,\r\n      function (result) {\r\n        // Do something with the new result\r\n        fetchResource(\r\n          anotherUrl,\r\n          function (result) {\r\n            // Do something with the new result\r\n          },\r\n          failureCallback\r\n        );\r\n      },\r\n      failureCallback\r\n    );\r\n  },\r\n  failureCallback\r\n);\r\n</pre><p>However, because&nbsp;<code>.then()</code>&nbsp;returns another promise, this is how to write the same instructions above with promises:</p><pre class=\"ql-syntax\" spellcheck=\"false\">fetchResource(url)\r\n  .then(handleResult, failureCallback)\r\n  .then(handleNewResult, failureCallback)\r\n  .then(handleAnotherResult, failureCallback);\r\n</pre><p>As you can see, calling promises does not require a nested syntax. You can even eliminate the repeated&nbsp;<code>failureCallback</code>&nbsp;to make the code a lot neater, which is something the upcoming section of the article will explore.</p><h2><strong>How to Handle Errors in a Promise</strong></h2><p>To handle errors in Promises, use the&nbsp;<code>.catch()</code>&nbsp;method. If anything goes wrong with any of your promises, this method can catch the reason for that error.</p><pre class=\"ql-syntax\" spellcheck=\"false\">Promise.reject(new Error()).catch((reason) =&gt; console.error(reason));\r\n// Error\r\n</pre><p>This time in our example, the error output is no longer ‘uncaught’ because of&nbsp;<code>.catch()</code>.</p><p>You can also use the&nbsp;<code>.catch()</code>&nbsp;method in a chain of promises. It catches the first error it encounters in the chain.</p><p>For instance, refactoring the chain of promises following the&nbsp;<code>fetchResource()</code>&nbsp;function from the example of the previous section. This how you can stop error callback repetition in your code.</p><pre class=\"ql-syntax\" spellcheck=\"false\">fetchResource(url)\r\n  .then(handleResult)\r\n  .then(handleNewResult)\r\n  .then(handleAnotherResult)\r\n  .catch(failureCallback);\r\n</pre><p>You can also use&nbsp;<code>.catch()</code>&nbsp;to check for errors in a group of promises before proceeding with further asynchronous operations.</p><pre class=\"ql-syntax\" spellcheck=\"false\">fetchResource(url)\r\n  .then(handleResult)\r\n  .then(handleNewResult)\r\n  .catch(failureCallback)\r\n  // Check for Errors in the above group of promises before proceeding\r\n  .then(handleAnotherResult);\r\n</pre><p>The&nbsp;<code style=\"color: var(--gray85);\"><strong>.catch()</strong></code>&nbsp;method addresses any errors in a promise without requiring the nesting of error callback functions.</p><p>To chain an asynchronous operation to a promise regardless of if the promise is resolved or not, use the&nbsp;<code>.finally()</code>&nbsp;method. The&nbsp;<code>.then()</code>&nbsp;method is how you handle the results of a promise writing individual conditions for both resolved and rejected.&nbsp;<code>.catch()</code>&nbsp;runs only when there is an error. But sometimes you might want an operation to run no matter what happens to earlier promises.</p><p>Using&nbsp;<code>finally()</code>&nbsp;helps prevent possible code repetition in&nbsp;<code>.then()</code>&nbsp;and&nbsp;<code>.catch()</code>. It is for operations you must run whether there is an error or not.</p><pre class=\"ql-syntax\" spellcheck=\"false\">fetchResource(url)\r\n  .then(handleResult)\r\n  .then(handleNewResult)\r\n  .finally(onFinallyHandle);\r\n</pre><p>The&nbsp;<code>finally()</code>&nbsp;method has a few use cases in real-world applications. It is important if you want to perform cleanup operations for activities the promise initiated. Another use case—on Front-End Web Applications—is making user interface updates like stopping a loading spinner.</p><h2><strong>How to Handle Many Promises at Once</strong></h2><p>It is possible to run more than one promise at a time. All the examples you have seen so far are for promises that run one after the other.</p><p>In the previous examples, promises run similarly to synchronous code in the sense that they wait for the previous one to be resolved or rejected. But you could have multiple promises that run in parallel.</p><p>Here are the available methods that can help us achieve this:</p><ul><li><code>Promise.all()</code></li><li><code>Promise.race()</code></li><li><code>Promise.any()</code></li><li><code>Promise.allSettled()</code></li></ul><p>In this section of the article, we'll review these methods.</p><h3><strong>The&nbsp;</strong><code><strong>Promise.all()</strong></code><strong>&nbsp;method</strong></h3><p><code style=\"color: var(--gray85);\"><strong>Promise.all()</strong></code>&nbsp;accepts an array of promises as an argument but returns a single promise as the output. The single promise it returns resolves with an array of values if all the promises in the input array are fulfilled. The array&nbsp;<code>Promise.all()</code>&nbsp;resolves with will contain the resolve values of individual promises in the input array.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise1 = Promise.resolve(`First Promise's Value`);\r\nconst promise2 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 3000, `Second Promise's Value`)\r\n);\r\nconst promise3 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 2000, `Third Promise's Value`)\r\n);\r\n\r\nPromise.all([promise1, promise2, promise3]);\r\n\r\n// Output on the console\r\n\r\n// *Promise {&lt;fulfilled&gt;: Array(3)}*\r\n\r\nPromise.all([promise1, promise2, promise3]).then((values) =&gt; {\r\n  values.forEach((value) =&gt; console.log(value));\r\n});\r\n\r\n// Output on the console\r\n\r\n// First Promise's Value\r\n// Second Promise's Value\r\n// Third Promise's Value\r\n</pre><p>If at least one promise in the input array does not resolve,&nbsp;<code>Promise.all()</code>&nbsp;will return a rejected promise with a reason. The reason for the rejection will be the same as that of the first rejected promise in the input array.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise1 = Promise.resolve(`First Promise's Value`);\r\nconst promise2 = new Promise((resolve, reject) =&gt;\r\n  setTimeout(reject, 2000, `First reason for rejection`)\r\n);\r\nconst promise3 = new Promise((resolve, reject) =&gt;\r\n  setTimeout(reject, 3000, `Second reason for rejection`)\r\n);\r\n\r\nPromise.all([promise1, promise2, promise3]);\r\n\r\n// Output on the console\r\n\r\n// *Promise {&lt;rejected&gt;: \"First reason for rejection\"}*\r\n</pre><p><code>Promise.all()</code>&nbsp;will run all the input promises before it returns a value. But it does not run the promises one after the other–instead it runs them at the same time.</p><p>This is why the total time it would take&nbsp;<code>Promise.all()</code>&nbsp;to return a value is roughly the time it would take the longest promise in the array to finish.</p><p><img src=\"https://www.freecodecamp.org/news/content/images/2023/06/quickpoll.png\" alt=\"Illustration showing when Promise.all() will produce a value\" height=\"753\" width=\"960\"></p><p>Despite that, it has to finish running&nbsp;<em style=\"color: var(--gray85);\">all</em>&nbsp;the promises before it returns anything.</p><h3><strong>The&nbsp;</strong><code><strong>Promise.race()</strong></code><strong>&nbsp;method</strong></h3><p><code>Promise.race()</code>&nbsp;accepts an array of promises as an argument and returns a single promise as an output. The single promise it returns is the fastest promise to finish running—resolved or not. This means&nbsp;<code>Promise.race()</code>&nbsp;will return the promise with the shortest execution time in an array of promises.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise1 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 3000, `First Promise's Value`)\r\n);\r\nconst promise2 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 2000, `Second Promise's Value`)\r\n);\r\nconst promise3 = Promise.resolve(`Third Promise's Value`);\r\n\r\nPromise.race([promise1, promise2, promise3]);\r\n\r\n// Output on the console\r\n\r\n// *Promise {&lt;fulfilled&gt;: \"Third Promise's Value\"}*\r\n</pre><p>In the example above, because&nbsp;<code>promise3</code>&nbsp;is a promise that resolves on being created,&nbsp;<code>Promise.race()</code>&nbsp;returns it as the fastest. Just like other&nbsp;<code>Promise</code>&nbsp;methods the article discusses in this section, it runs the promises in parallel and not one after the other.</p><p>If the promise with the shortest execution time happens to be rejected with a reason,&nbsp;<code>Promise.race()</code>&nbsp;returns a rejected promise and the reason why the fastest promise was rejected.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise1 = Promise.reject(`Reason for rejection`);\r\nconst promise2 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 3000, `First resolved Promise`)\r\n);\r\nconst promise3 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 2000, `Second resolved Promise`)\r\n);\r\n\r\nPromise.race([promise1, promise2, promise3]);\r\n\r\n// Output on the console\r\n\r\n// *Promise {&lt;rejected&gt;: \"Reason for rejection\"}*\r\n</pre><p><img src=\"https://www.freecodecamp.org/news/content/images/2023/06/quickpoll--3-.png\" alt=\"Illustration showing when Promise.race() will produce a value\" height=\"772\" width=\"1040\"></p><p><code>Promise.race()</code>&nbsp;is useful for running a list of asynchronous operations but only needing the result of the fastest executed operation.</p><h3><strong>The&nbsp;</strong><code><strong>Promise.any()</strong></code><strong>&nbsp;method</strong></h3><p><code>Promise.any()</code>&nbsp;accepts an array of Promises as an argument but returns a single Promise as the output. The single promise it returns is the first resolved promise in the input array. This method waits for&nbsp;<em style=\"color: var(--gray85);\">any</em>&nbsp;promise in the array to be resolved and would immediately return it as the output.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise1 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 3000, `First Promise's Value`)\r\n);\r\nconst promise2 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 2000, `Second Promise's Value`)\r\n);\r\nconst promise3 = Promise.reject(`Third Promise's Value`);\r\n\r\nPromise.any([promise1, promise2, promise3]);\r\n\r\n// Output on the console\r\n\r\n// *Promise {&lt;fulfilled&gt;: \"Second Promise's Value\"}*\r\n</pre><p>From the above example,&nbsp;<code>promise1</code>&nbsp;will resolve after 3 seconds,&nbsp;<code>promise2</code>&nbsp;will resolve after 2 seconds, and&nbsp;<code>promise3</code>&nbsp;immediately rejects. Because&nbsp;<code>Promise.any()</code>&nbsp;is looking for the first successful promise, it returns&nbsp;<code>promise2</code>.&nbsp;<code>promise1</code>&nbsp;is a little bit late and so it's left behind.</p><p>If none of the promises in the array are resolved,&nbsp;<code style=\"color: var(--gray85);\"><strong>Promise.any()</strong></code>&nbsp;returns a rejected promise. This rejected promise contains a JavaScript array of reasons, where each reason corresponds with that of a promise from the input array.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise1 = new Promise((resolve, reject) =&gt;\r\n  setTimeout(reject, 3000, `First rejection reason`)\r\n);\r\nconst promise2 = new Promise((resolve, reject) =&gt;\r\n  setTimeout(reject, 2000, `Second rejection reason`)\r\n);\r\nconst promise3 = Promise.reject(`Third rejection reason`);\r\n\r\nPromise.any([promise1, promise2, promise3]);\r\n\r\n// Output on the console\r\n\r\n// *Promise {&lt;rejected&gt;: Aggregate Error: All Promises were rejected}*\r\n\r\nPromise.any([promise1, promise2, promise3]).catch(({ errors }) =&gt;\r\n  console.log(errors)\r\n);\r\n\r\n// Output on the console\r\n\r\n// *(3) [\"First* rejection reason*\", \"Second* rejection reason*\", \"Third* rejection reason*\"]*\r\n</pre><p>This method is useful for asynchronous operations where the fastest successful promise is all you need.&nbsp;<code>Promise.any()</code>&nbsp;and&nbsp;<code>Promise.race()</code>&nbsp;are similar, except that&nbsp;<code>Promise.any()</code>&nbsp;will return the fastest promise to complete and be resolved, while&nbsp;<code>Promise.race()</code>&nbsp;will return the fastest promise to complete and does not care if it is resolved or not.</p><p><br></p>","coverImageUrl":"https://escribir.s3.eu-north-1.amazonaws.com/1730731585593_lvpfnugwgoa","createdAt":"2024-11-04T14:46:28.066Z","heading":"What is a Promise?","reactions":[],"status":"published","tag":"JavaScript","updatedAt":"2024-11-09T05:21:12.915Z"},"1":{"__v":0,"_id":"6728abf41aec9bbaf4acfbf8","author_id":{"_id":"6719d873a7ce679095b76e01","image":"https://res.cloudinary.com/djfhotv8n/image/upload/v1729747676/Escribir_Profile_Images/ybc9vtwqaqnly2lkwjhu.jpg","username":"Sneha K"},"comments":[],"content":"<h2>Peace Starts When We Embrace Who We Are, Not Who We Should Be</h2><p><img src=\"https://cdn-images-1.readmedium.com/v2/resize:fit:800/1*3Vuj3LOBgHyrDZjmkU4Dig.png\">Image created by author using&nbsp;<a href=\"https://www.midjourney.com/app/\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: inherit;\">MidJourney</a></p><p><br></p><p><br></p><p><em>“You’re doing better than you think. Stop being so hard on yourself,”</em>&nbsp;I told my friend as he sat across from me, tears streaming down his face. His voice cracked as he repeated the words:&nbsp;<em>“I failed her. I’m not good enough. I’ll never be good enough.”&nbsp;</em>I didn’t know what else to say to him. Here was someone who had never truly accepted himself, no matter how much he accomplished.</p><p>My friend had built a multimillion-dollar business from nothing, rising out of poverty. He cared for his aging parents, sent two siblings to college, and even helped them get married — all before he turned forty. Yet, despite these incredible achievements, his response was always the same whenever I praised him:&nbsp;<em>“Not good enough. Not yet.”</em></p><p>I know this mindset well, having grown up in an entrepreneurial family where my performance was constantly measured through comparisons.<em>“Look at so-and-so’s son and how well he’s doing,”</em>&nbsp;my father would say. That sense of comparisons and expectations was relentless. The thought of meeting these standards blinded me to the 90% of things I was doing right. Instead, I became fixated on the never-ending 10% I hadn’t achieved to prove myself, and if not, I would become bitter toward myself and those I was trying to match in performance. I would develop an inflated self-confidence that I would crush all aspects of business or have zero to no confidence in certain business activities.</p><p>When I didn’t feel competitive enough, I lost opportunities and friendships when there was a better approach for collaboration and a win-win. I often didn’t know why I was competing; I just wanted to prove to my father that I was better than the other guy, and he was wrong. Initially, things might feel like you are improving and moving forward. Still, the amount of poison and negative energy you inject into yourself is much more damaging than the instant pleasure of the wins. At last, my father realized he was doing more damage than good when, during a fight, I told him, “How about you adopt one of those guys as your son, and I will find myself a better father?” It was a shock to him but a natural response from my side, being drained and always trying to follow his ideal image of the perfect son.</p><p>I have realized that one of our biggest mistakes when we don’t value ourselves is that we tie our self-worth to specific goals, metrics, or others’ constant demands and expectations. When we do that, falling short makes us feel worthless. We see ourselves as either winners or losers, with no middle ground. I had been there for a long time, and it took me countless reflections to understand that It’s tough to break free from this negative cycle unless I completely realize that my circumstances shaped my life. We all have our strengths and weaknesses and can control only so much.</p><p>My friend’s heartbreak wasn’t just about the end of his relationship; it was the overwhelming pressure he had placed on himself to be perfect in every part of his life. His girlfriend left because he was sometimes too focused on his business, not always free or mentally ready for her constant desire to hang out at social events with her friends. While he blamed himself, I knew he had always done his best given the circumstances.&nbsp;<em>“What more could you expect from yourself?”</em>&nbsp;I asked him.&nbsp;<em>“How else could you have acted within your conditions? Come on, man, at least give yourself credit for doing your best.”</em></p><p>His situation reminded me of my own struggles with self-acceptance. It took me a great deal of time to realize that self-acceptance doesn’t mean we must agree with everything we’ve done or be happy with every outcome. It simply means recognizing our efforts and staying true to ourselves. His girlfriend compared him to her friend’s boyfriends, men who might have far fewer responsibilities. Was that fair? Maybe not. He might not have been the perfect boyfriend, but he was doing his best with what life threw at him.</p><p>Through tears running down his face, he told me that night,&nbsp;<em>“I’m so tired. I don’t know what I did wrong. I gave everything I had. I don’t even know who I am anymore. Every day, I wake up trying to meet everyone’s expectations, and by the end of the day, I break into bed, exhausted. Yet, no matter what I do or how much I ‘fix’ myself, I still feel like I’m not good enough unless I meet their standards.”</em></p><p>“<em>That’s because you’re expecting happiness through changing your core to satisfy others,</em>” I told him. “<em>And no one can keep going with that for too long.</em>”</p><p>That conversation taught me a lesson I will never forget: the constant “go, go, go” mentality—the relentless craving to make everyone happy—comes at the cost of living in the present. We’re always chasing an idealized future of ourselves that never brings real happiness. We are constantly walking toward a mirage, only to find emptiness when we arrive, with a sign telling us to continue until we’re drained and broken by exhaustion.</p><p>In the past, I’ve also confused personal growth with self-acceptance, which has driven me to exhaustion in the name of “endless progress.” It’s natural to want more and to grow, but real change only happens when we acknowledge who we are despite the expectations of others or an ideal image of ourselves. Change can’t come from denying ourselves—denial leads to self-destruction. It traps us in a cycle of dwelling on past mistakes and constantly questioning our worth whenever we fall short of someone else’s standards.</p><p>At that conversation, I wished my friend could accept himself; I wish he didn’t blame himself for his past, and I wish he could live in the present and trust that despite his painful experiences, he could still grow and evolve in future relationships. Yes, his girlfriend might be wonderful, and he might be short on delivering sometimes, but maybe she wasn’t the right person for him at that point, which he realizes today.</p><p>Gladly, now he has changed his approach. Instead of trying to change himself entirely for someone, he is very open and transparent about his circumstances when he goes out on a date. It’s much happier to be honest and true to ourselves and find those who match and accept our circumstances than to change our cores to attract or maintain someone who is unwilling to see the committed part in us.</p><p><img src=\"https://cdn-images-1.readmedium.com/v2/resize:fit:800/1*-e_-zcnK0faNwbvMQonFCA.png\">Image created by author using&nbsp;<a href=\"https://www.midjourney.com/app/\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: inherit;\">MidJourney</a></p><p><br></p><p><br></p><p>Self-acceptance is difficult for many because it takes tremendous courage to be brutally honest with ourselves. It requires us to look at who we are without denial or avoidance. When we see the parts of ourselves that don’t measure up to someone else’s standards, we must also recognize the good in us — the beautiful qualities and positive force that contribute to the lives of others. That’s not easy when everyone holds you to expectations that make you feel unworthy the moment you fall short.</p><p>We all need to understand that individually we are whole beings, and collectively we paint the whole picture. You are not just a collection of good and bad parts — you are a complete person. You have strengths in certain areas, and the people you choose in life should complement you just as you complement them.</p><p>When you accept yourself and allow yourself to grow into your best form, you’ll realize that you only need to meet your natural and basic expectations, not anyone else’s. That’s when you begin to live authentically and give others the space to grow into their best selves within their abilities and circumstances.</p><p>That night, I told my friend, “<em>You don’t need all the answers right now, and that’s okay. Just understand that this is who you are, and this is your situation. Be at peace with that and move forward from there. The end of your relationship doesn’t mean you’re unlovable or incapable of giving love.</em>” I wasn’t asking him to ignore the pain or pretend nothing happened, but to acknowledge it without letting it define him. I encouraged him to see himself not as someone who failed but as someone who tried, learned, and is still standing despite it all, and today, he is finding more joy in his dating life.</p><p><br></p><p>One important lesson I’ve learned from painful experiences is to avoid comparing myself to others or being compared to anyone at any cost. I understand that life can be competitive, but comparison is not the right approach to growth. It’s the enemy of self-acceptance, breeding feelings of inadequacy. When we compare ourselves, we might create slightly better versions than others, but it comes at the expense of our authenticity. It traps us in a cycle of feeling worthless, never enough, and incapable. When we learn to see our authentic beauty, we also begin to see it in others without neglecting our self-worth. Others can inspire us, but we don’t need to become a copy of someone else in the name of improvement or to meet the demands of others.</p><p>Life teaches us that nature thrives in diversity. Each of its creations grows according to its strengths and circumstances. Denying the best in ourselves is denying the gifts life has given us. An oak tree doesn’t strive to become a smaller banana tree or a much larger mountain. It grows into its most natural and beautiful form, providing shade and strength for those who need it. That’s the essence of self-acceptance: it’s to become the best version of yourself, free from comparison. When you truly embrace that, everything else follows naturally.<strong>&nbsp;Cheers!</strong></p><p><br></p>","coverImageUrl":"https://escribir.s3.eu-north-1.amazonaws.com/1730718702669_aww8gabts9h","createdAt":"2024-11-04T11:11:48.729Z","heading":"When You Accept Yourself, Everything Else Falls Into Place","reactions":[],"status":"published","tag":"Self-Motivation","updatedAt":"2024-11-04T11:11:48.729Z"},"2":{"__v":0,"_id":"6728aaee1aec9bbaf4acfbe6","author_id":{"_id":"6719d873a7ce679095b76e01","image":"https://res.cloudinary.com/djfhotv8n/image/upload/v1729747676/Escribir_Profile_Images/ybc9vtwqaqnly2lkwjhu.jpg","username":"Sneha K"},"comments":[],"content":"<h2><br></h2><h1><br></h1><h1>How slowing down helped me move from burnout to clarity and finally discover the meaning behind my work and life</h1><h1><br></h1><p><img src=\"https://cdn-images-1.readmedium.com/v2/resize:fit:800/1*KGZwmYeby0MYf8E3pWnntA.png\">Image created by author using&nbsp;<a href=\"https://www.midjourney.com/app/\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: inherit;\">MidJourney</a></p><p><br></p><p><br></p><p><em>“I can’t stop! If I do, I’ll lose momentum, and everything I’ve built will fall apart!”</em>&nbsp;I replied in frustration.</p><p>My friend stared at me in confusion and said,&nbsp;<em>“What’s the point of it all if you’re the one falling apart?”</em></p><p><br></p><p><em><span class=\"ql-cursor\">﻿</span></em></p><p><strong>I froze. I had no answer!</strong></p><p>A few years ago, I believed that worthy accomplishment was defined by non-stop action. I thought the harder I pushed, the closer I’d get to the finish line of success. I assumed if I filled every second of my day with tasks and deadlines, I’d look and feel busy, and my goals would be achieved on autopilot.</p><p>But, in truth, I was driven by fear of falling behind. I was insecure and terrified of appearing lazy or like a procrastinator. I lived in megacities where more work was glorified, and constant busyness was a badge of discipline and focus. The problem was that the more I convinced myself I was doing the right thing, the more disconnected I became from myself. My behavior was making me less productive and even more ineffective. I spent time doing things but saw little to no noticeable return.</p><p>Looking back, I realize I left no room for reflection, no space to question whether I was doing things right. Pausing isn’t laziness; it’s wisdom. Stepping back from the noise and constant movement allows us to create space for clarity, reflection, and meaningful progress.</p><p>I often worked on projects for over 48 hours straight, with little to no sleep, forgetting and dismissing eating or even hydrating myself well. If you looked at my face, you’d see red eyes surrounded by dark circles — a zombie drained of energy. Like many of us, I, too, felt like everyone else was moving faster, and I couldn’t afford to stop. Pausing, to me, meant failure. I wish I’d known then that true success isn’t about how busy we are but about the intention behind our actions and the meaning behind our goals.</p><p>How many of us assume busyness gives us purpose? In reality, it steals our joy and clarity. We’re constantly driven by the need to prove ourselves, but in that pursuit, we forget that our well-being and happiness matter the most. When we don’t pause, breathe, and reflect, we never allow ourselves to realign with what truly matters. True accomplishment isn’t about how much we push — it’s about understanding when to take a step back and preventing ourselves from pushing too far into exhaustion</p><p>My attitude didn’t bring me the success I wanted. It led me to anxiety and depression. I became physically exhausted, mentally drained, and emotionally numb. Day after day, I watched my design proposals slip away to competitors who invested less effort but more “<strong>thoughtfulness</strong>.”</p><p>Mental health is a serious matter, and it made me stop. I was drained of energy and lacked motivation, even for the smallest tasks. My friends didn’t understand the situation and encouraged me to ignore my feelings and press on, but the harder I pushed, the more my mind and body fought back.</p><p>One night, I lost a design proposal I had spent so many days on and smashed my MacBook Pro against the wall. My ex-wife thought I was angry, but the underlying truth was I was desperate. I was hungry for success, yet my efforts yielded nothing. I listened to endless motivational videos to encourage myself, but practicality said otherwise.</p><p>The problem with the go-go-go mentality is that it fosters a scarcity mindset — do it now, or it’ll never happen. The truth is that opportunities will always exist, and we can achieve success if we slow down and think through our intentions.</p><p>My teacher in Shanghai, a wise, practical, and successful man in his 50s, captured this perfectly. One day, he told me, “<em>Maybe you are doing the right thing, but perhaps you are not doing it right. Learn to pause, move in small steps, and protect your well-being. Once you’re exhausted, it’s game over. People who aim to win know how to play longer while feeling their best.”</em></p><p>What he said was deep and true, many of us pursue the right goals, but our approach might be wrong. We put our relationships, mental health, and physical well-being at risk in the hope of achieving a future success that, to be honest, is unpredictable. We rush through everything and end up with nothing but exhaustion.</p><p>When we lose confidence, we think we’re not good enough for the job, when in reality, all we needed were moments of stillness to reflect and refill our energy. That’s why so many lose faith in themselves despite having the strength and talent to achieve their goals — if only they slowed down, contemplated, and took one small step at a time.</p><p>Burnout doesn’t happen overnight. I’ve experienced it countless times in my life. When we push ourselves beyond our limits, exhaustion becomes unavoidable. Once it takes hold, we lose clarity and purpose. What once felt meaningful becomes draining. Burnout is our spirit’s way of demanding that we need to stop.</p><p>At first, the idea of pausing and taking a step back was impossible to accept. It was completely uncomfortable because I thought I’d lose grip. It’s interesting when the brain is hooked on believing that more work equals greatness and rejects the thought of stepping away. The idea of turning off my computer, sitting on my balcony, or walking in the park without listening to a productivity book felt like proof of laziness.</p><p>What I forgot was that hardcore motivational talk is easy to say but, at times, impractical to follow. We’re human and vary in our energy levels, hormones, and emotions. There is a limit to how much we can push. I learned through experience that no matter how much guilt rushes through our minds, reminding us of what we “<strong>should</strong>” be doing, we’ll never feel like we’re doing enough — it’s human nature to want to achieve more and more.</p><p>But we forget that, at some point, our bodies will tire and push back. That’s when we have to stop, listen to our bodies, and root our sense of accomplishment in reality. Because even if we achieve materialistic success, without inner peace and moments of true relaxation, our lives will start to feel unbalanced, and the motivation and meaning we once had may begin to fade.</p><p><img src=\"https://cdn-images-1.readmedium.com/v2/resize:fit:800/1*qkct7UqT5UTJTTlpNo6YDg.png\">Image created by author using&nbsp;<a href=\"https://www.midjourney.com/app/\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: inherit;\">MidJourney</a></p><p><br></p><p><br></p><p>My first conscious step back happened when I left my phone at home and went for a walk in the park for an hour. At first, I was worried about missing messages. But then I paused and asked myself,<em>&nbsp;“What is wrong with you? You’ve been working non-stop for years, and you’ve gotten nowhere near your goals. Why do you think this one hour will make any difference?”</em></p><p>I realized I was looking busy all the time, but I wasn’t productive. I was just stuck behind my screen, eyeballs tracking the curser. When I assured myself that nothing would happen in that hour, I shifted my attention from the constant noise in my head urging me to keep overthinking about my work to the beauty of the world around me.</p><p>I noticed an elderly man who had brought a chicken to the park, letting kids play with it. Some cats in the park stared at the chicken, and a few even tried to chase it, but the man kept shooing them away. It was a joyful moment, and people laughed as they watched. The scene made me appreciate the beauty and vibrancy of the world around me, filling me with a sense of joy.</p><p>As I walked through the park, I felt the warmth of the sunlight, the breeze of fresh air, and the scent of beautiful Gardenia flowers. The tension in my muscles and the fogginess in my mind began to fade. My chest felt lighter, my breath deeper, and my thoughts clearer.</p><p>Many of us struggle with the silence that comes with stillness, but in these moments, we confront the truths buried under the weight of busyness. Learning to pause, even for small moments, helps us release what no longer serves us and discover a deeper sense of purpose. Clarity doesn’t come from doing more but from stepping back and creating space to think mindfully.</p><p>Pausing and reflecting have now become part of my daily routine. Whenever I feel myself rushing into work, I remind myself that this path only leads to burnout and exhaustion.</p><p>Sometimes, I call a friend and escape to a coffee shop or arcade for some lighthearted fun, stepping away from the constant pressure of work. These moments are important; they give me a much-needed break and allow my mind to reset.</p><p>During these moments of relaxation, I take the time to ask myself, What do I truly want? Why am I doing this? With greater clarity, I approach my work with intention, recognizing that if I’m not enjoying what I’m doing, it may not align with my passions. This realization often leads me to consider letting go of what no longer serves me and seeking out opportunities that better reflect my values. Once refreshed, I return feeling rejuvenated and ready to tackle my tasks with renewed energy.</p><p>There is a quote by John Lennon, “The time you enjoy wasting is not wasted time.” This quote resonates because pausing brings real value to our lives and is a wise use of time; it allows us to relax and act with intention, leading to more meaningful outcomes.</p><p>On the other hand, staying busy for the sake of it or rushing through projects without taking a moment to reflect on our goals and actions wastes both time and energy, often resulting in unclear aims and inefficient efforts. Pausing doesn’t mean losing momentum; it means gaining clarity and avoiding unnecessary mistakes. It allows us to approach tasks with a refreshed perspective, often leading to insights we might miss if we’re always in motion.</p><p>This change in my mindset has greatly helped me guide others toward clearer thinking as well. In my consulting business, when I see clients rushing, I urge them to slow down because, without thoughtfulness, we risk producing ineffective work that may need to be redone later. When they slow down and take the time to think about their decisions and actions, they approach tasks with more intention and ultimately appreciate the results of their careful investments — whether of time, effort, or money.</p><p><img src=\"https://cdn-images-1.readmedium.com/v2/resize:fit:800/1*IGU-4m4waL-tcb837JlbwQ.png\">Image created by author using&nbsp;<a href=\"https://www.midjourney.com/app/\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: inherit;\">MidJourney</a></p><p><br></p><p>This mindset adds “<strong>quality”</strong>&nbsp;to our lives — a concept we need to learn to embrace if we seek personal improvement. When we prioritize our mental, emotional, and physical health, everything else aligns harmoniously, allowing us to pursue our goals purposefully.</p><p>The world often demands continuous action, whether from work, relationships, or other commitments. When we fail to pause and recharge, it leads to burnout. Pausing shifts our focus from solely completing tasks to being present, allowing us to reflect on what truly matters in our lives. It allows us to consider our priorities and the relationships we value the most.</p><p>Next time you feel like you can’t stop, take a deep breath and&nbsp;<strong>ask yourself:&nbsp;</strong>What’s more important — blindly pushing forward or stepping back to find clarity? Are you moving with purpose or just keeping up with the pace? When we aim for peace, growth follows. Clarity emerges when you take a step back and trust that intention drives progress.&nbsp;<strong>Reflect on this:&nbsp;</strong>When given the choice, wouldn’t you prefer clarity over chaos? Here’s to choosing with intention.&nbsp;<strong>Cheers!</strong></p><p><br></p>","coverImageUrl":"https://escribir.s3.eu-north-1.amazonaws.com/1730718444147_v2tldzczzqq","createdAt":"2024-11-04T11:07:26.282Z","heading":"When You Pause, Your True Purpose Reveals Itself","reactions":[],"status":"published","tag":"Self-Motivation","updatedAt":"2024-11-04T11:07:26.282Z"},"3":{"__v":0,"_id":"6728a6761aec9bbaf4acfbd5","author_id":{"_id":"66ebecd0eb53f2be6b08101d","image":"https://res.cloudinary.com/djfhotv8n/image/upload/v1729616317/Escribir_Profile_Images/m4liuexkuts6xr6bdngp.jpg","username":"Jansiya jahan"},"comments":[],"content":"<h3><strong>Visual representations</strong></h3><p>I think it’s always good to start with some visualization.</p><p>Here are the most common pictures of this concept.</p><p><img src=\"https://cdn-media-1.freecodecamp.org/images/oVVbTLR5gXHgP8Ehlz1qzRm5LLjX9kv2Zri6\" alt=\"Image\" height=\"567\" width=\"772\"></p><p><img src=\"https://cdn-media-1.freecodecamp.org/images/YsN6twE3-4Q4OYpgxoModmx29I8zthQ3f0OR\" alt=\"Image\" height=\"400\" width=\"600\">_Source and credit: [https://www.codingblocks.net/podcast/clean-architecture-make-your-architecture-scream/](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html\" rel=\"noopener\" target=\"_blank\" title=\"\"&gt;https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html .&lt;a href=\"https://www.codingblocks.net/podcast/clean-architecture-make-your-architecture-scream/\" rel=\"noopener\" target=\"<em style=\"color: var(--gray85);\">blank\" title=\")</em></p><p><img src=\"https://cdn-media-1.freecodecamp.org/images/lbexLhWvRfpexSV0lSIWczkHd5KdszeDy9a3\" alt=\"Image\" height=\"400\" width=\"600\"></p><p><img src=\"https://cdn-media-1.freecodecamp.org/images/YIABVRTHRz58ZiT6W-emBkfNIQUHBelp8t6U\" alt=\"Image\" height=\"400\" width=\"600\">_Source and credit: Mattia Battiston, under CC BY 4.0, [https://github.com/mattia-battiston/clean-architecture-example](https://github.com/mattia-battiston/clean-architecture-example\" rel=\"noopener\" target=\"<em style=\"color: var(--gray85);\">blank\" title=\")</em></p><p><img src=\"https://cdn-media-1.freecodecamp.org/images/TmSQbZOg5bxn0cRXxIrRUd2zhqeDAXTe8ni5\" alt=\"Image\" height=\"400\" width=\"600\">_Source and credit: [https://marconijr.com/posts/clean-architecture-practice/](https://marconijr.com/posts/clean-architecture-practice/\" rel=\"noopener\" target=\"<em style=\"color: var(--gray85);\">blank\" title=\")</em></p><h3><strong>The concept — presented in bullet points</strong></h3><p>Extended from Source and credit:&nbsp;<a href=\"https://github.com/mattia-battiston/clean-architecture-example\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: var(--gray90); background-color: transparent;\">Mattia Battiston, under CC BY 4.0</a></p><h4><strong>The value it can provide</strong></h4><ul><li>An effective testing strategy that follows the testing pyramid</li><li>Frameworks are isolated in individual modules. When (not if) we change our mind, we only have to make a change in one place. The app has use cases rather than being tied to a CRUD system</li><li>Screaming architecture a.k.a. it screams its intended usage. When you look at the package structure, you get a feel for what the application does rather than seeing technical details</li><li>All business logic is in a use case, so it’s easy to find and not duplicated anywhere else</li><li>Hard to do the wrong thing because modules enforce compilation dependencies. If you try to use something that you’re not meant to, the app doesn’t compile</li><li>It is always ready to deploy by leaving the wiring up of the object for last. Or by using feature flags, so we get all the benefits of continuous integration</li><li>Multiple works on stories so that different pairs can easily work on the same story at the same time to complete it quicker</li><li>Good monolith with clear use cases that you can split in microservices later on, once you’ve learned more about them</li></ul><h4><strong>Entities</strong></h4><ul><li>Represent your domain object</li><li>Apply only logic that is applicable in general to the whole entity (e.g., validating the format of a hostname)</li><li>Plain objects: no frameworks, no annotations</li></ul><h4><strong>Use Cases</strong></h4><ul><li>Represent your business actions: it’s what you can do with the application. Expect one use case for each business action</li><li>Pure business logic, plain code (except maybe some utils libraries)</li><li>The use case doesn’t know who triggered it and how the results are going to be presented (for example, could be on a web page, or — returned as JSON, or simply logged, and so on.)</li><li>Throws business exceptions</li></ul><h4><strong>Interfaces / Adapters</strong></h4><ul><li>Retrieve and store data from and to a number of sources (database, network devices, file system, 3rd parties, and so on.)</li><li>Define interfaces for the data that they need in order to apply some logic. One or more data providers will implement the interface, but the use case doesn’t know where the data is coming from</li><li>Implement the interfaces defined by the use case</li><li>There are ways to interact with the application, and typically involve a delivery mechanism (for example, REST APIs, scheduled jobs, GUI, other systems)</li><li>Trigger a use case and convert the result to the appropriate format for the delivery mechanism</li><li>the controller for a MVC</li></ul><h4><strong>External Interfaces</strong></h4><ul><li>Use whatever framework is most appropriate (they are going to be isolated here anyway)</li></ul><h3><strong>Code example</strong></h3><p>See the structure on&nbsp;<a href=\"https://github.com/Createdd/web-miner/tree/master/webminer\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: var(--gray90); background-color: transparent;\">GitHub</a>.</p><p>First of all, it is important to understand that clean architecture is a bundle of organising principles. So therefore everything is open to personal adjustments as long as core ideas are kept intact. The linked repository is a fork of the original project that brought this architecture design idea to me. Feel free to check out the original project as well, as it reflects further improvements.</p><p>The webminer folder is structured into the basic layers:</p><ol><li>entities</li><li>use_cases</li><li>interfaces_adapters</li><li>external_interfaces</li></ol><p><img src=\"https://cdn-media-1.freecodecamp.org/images/FSvBm5GdWA0uMo6NJhyOoF2hgJt8s1Bv3n1v\" alt=\"Image\" height=\"400\" width=\"600\"><em style=\"color: var(--gray85);\">Structure of the webminer folder</em></p><p>It shall reflect the very basic approach for the design pattern.</p><ul><li>Starting from&nbsp;<code>entities</code>, you can see that the core model of this project is the&nbsp;<code>arxiv_document</code></li><li>The next folder,&nbsp;<code>use_cases</code>&nbsp;shows our use case, namely to request the arxiv page</li><li>After that, we go through the&nbsp;<code>interface_adapters</code>&nbsp;folder that provides adapters for process requests in a REST application or for serializing</li><li>The final and last layer is&nbsp;<code>external_interfaces</code>. This is where we use the flask server to implement the REST functionality</li></ul><p>All of those layers are dependent on the core layers but not the other way around.</p><p><strong style=\"color: var(--gray85);\">One important note: This is not 100% correctly implemented in the repository.</strong></p><p>Why? Because the use cases are actually different. In reality the main use case is to provide the structured data. Another use case is to get the data from the arxiv page.</p><p>Did you spot this error in the architecture? If yes, congratulations! Not only did you bring enough curiosity to this article but you likely understand the principles well enough to build your own case and apply the concepts in reality!</p><p>Do you agree? If not, why? Thanks for reading my article! Feel free to leave any feedback!</p>","coverImageUrl":"https://escribir.s3.eu-north-1.amazonaws.com/1730717299890_5yzadkrd3l5","createdAt":"2024-11-04T10:48:22.122Z","heading":"A quick introduction to clean architecture","reactions":[],"status":"published","tag":"JavaScript","updatedAt":"2024-11-04T10:48:22.122Z"},"4":{"__v":0,"_id":"6728a6291aec9bbaf4acfbcd","author_id":{"_id":"66ebecd0eb53f2be6b08101d","image":"https://res.cloudinary.com/djfhotv8n/image/upload/v1729616317/Escribir_Profile_Images/m4liuexkuts6xr6bdngp.jpg","username":"Jansiya jahan"},"comments":[],"content":"<p><span style=\"color: rgb(36, 36, 36);\">TypeScript is an open-source programming language developed by Microsoft. It is a statically typed superset of JavaScript, which means that any valid JavaScript code is also valid TypeScript code. However, TypeScript adds optional static typing and other features to help developers write more scalable and maintainable code. TypeScript and JavaScript are like brothers. As you know JavaScript was made in year of 1995 only in ten days it show how hurriedly in urgency they made this language so it have so many errors but now after so many upgrades its good to go. but now we have TypeScript which is more tackle-able as compared to JavaScript so in TypeScript</span></p><p><br></p><ul><li><span class=\"ql-cursor\">﻿</span>TypeScript&nbsp;<a href=\"https://www.youtube.com/redirect?event=video_description&amp;redir_token=QUFFLUhqbFFvT1ZkSnVYUllvZ0JPZTg5b2FmbkRBN3lOd3xBQ3Jtc0tubXkxQWo1SjNoelFjSTk4dnZvMXlkTEVNamp3WDNPYTlURzBfSXZXS2RtMmJHRmp0S2dLaHNjS25nVUFuNVlWdFdMWk1EUU1DQXBRVldTb3JWTk9Uc1lRcElkRmxpckZHVFgwYnFZWHducDdwNEdlMA&amp;q=https%3A%2F%2Fwww.typescriptlang.org%2Fdownload&amp;v=f3xeJOvqUPQ\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: inherit;\">https://www.typescriptlang.org/download</a></li></ul><p><br></p><p><span style=\"color: rgb(36, 36, 36);\"><img src=\"https://miro.medium.com/v2/resize:fit:708/1*-GCUmL0FbFSpT2SLa74P4Q.png\" alt=\"https://www.typescriptlang.org/download\" height=\"215\" width=\"566\"></span></p><p><span style=\"color: rgb(36, 36, 36);\">So here’s a breakdown of some key concepts in TypeScript:</span></p><ul><li>Static Typing: TypeScript allows you to specify types for variables, function parameters, return types, and more. This helps catch type-related errors during development and provides better tooling support for code editors.</li><li>Type Inference: TypeScript’s type inference system can often automatically infer types based on how you’ve written your code. This means you don’t always have to explicitly specify types, though you can if you want to be more explicit.</li><li>Interfaces and Types: TypeScript allows you to define custom types using interfaces and types. These can describe the shape of objects, including the types of their properties and methods.</li><li>Classes and Inheritance: TypeScript supports object-oriented programming features like classes, inheritance, and access modifiers (public, private, and protected).</li><li>Enums: TypeScript provides support for enums, which allow you to define a set of named constants. Enums are useful when you have a fixed set of values that a variable can take.</li><li>Generics: TypeScript supports generics, which allow you to write reusable code that can work with a variety of data types while still maintaining type safety.</li><li>Modules: TypeScript supports modular programming through the use of modules. You can import and export functionality between different files, which helps organize code and manage dependencies.</li></ul><p>Overall, TypeScript aims to make it easier to build large-scale JavaScript applications by adding features that help catch errors early, improve code maintainability, and provide better tooling support. It compiles down to plain JavaScript, through node.js it works as a compiler in between JS &amp; TS so it easily run on any JavaScript runtime, making it a versatile choice for web development.<span style=\"color: rgb(36, 36, 36);\">&nbsp;</span></p>","coverImageUrl":"https://escribir.s3.eu-north-1.amazonaws.com/1730717223118_5njbdoap6ps","createdAt":"2024-11-04T10:47:05.763Z","heading":"Introduction To TypeScript","reactions":[],"status":"published","tag":"TypeScript","updatedAt":"2024-11-04T10:47:05.763Z"},"5":{"__v":0,"_id":"67288d201aec9bbaf4acfb11","author_id":{"_id":"66ebecd0eb53f2be6b08101d","image":"https://res.cloudinary.com/djfhotv8n/image/upload/v1729616317/Escribir_Profile_Images/m4liuexkuts6xr6bdngp.jpg","username":"Jansiya jahan"},"comments":[],"content":"<p><img src=\"https://miro.medium.com/v2/resize:fit:875/0*kCfge4a9Xm0zyqcP\" height=\"394\" width=\"700\"></p><p><strong>First lets Define what WebRTC is</strong></p><p>WebRTC is a set of JavaScript API’s that allow us to establish a peer to peer connection between two browsers to exchange data such as audio and video, allowing us to create applications with audio and video calling features.</p><p>What makes WebRTC special is that once a connection is established; data can be transmitted directly between browsers in real time without touching the server.&nbsp;By bypassing the server we reduce latency since the data doesn’t have to go to the server first, this makes webRTC great for exchanging audio and video.</p><p>Full video tutorial: “<a href=\"https://youtu.be/8I2axE6j204\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: inherit;\">How Does WebRTC Work? | Crash Course</a>”</p><p><strong>WebRTC Vs WebSockets</strong></p><p>Before we talk about how all this works, let’s look at the comparison between WebRTC and WebSockets since I know a lot of you are thinking “this sounds a lot like WebSockets, so why do we need WebRTC?” or vice versa.</p><p><img src=\"https://miro.medium.com/v2/resize:fit:875/0*Own87NQd76MSw2hc\" height=\"308\" width=\"700\"></p><p>With websockets we can also establish a connection between peers to exchange data in real time, but this connection is between the client and server. So if I send a message to a peer, the message first goes to the server, then the server sends that message to the other peer. This exchange typically happens really fast so even though there is some latency, you probably wouldn’t even notice it if you’re sending something like a chat message or some kind of notification.</p><p>Now let’s say we wanted to exchange some audio or video using websockets, after all this is possible.</p><p>The problem here is that even the slightest latency when it comes to audio and video can be very noticeable and causes a lot of issues. So by the time your video data hits the server and back to your peer, you’re gonna see a significant delay.</p><p>This is where webRTC makes sense. By establishing a connection and exchanging data between two browsers we eliminate any delay that the server may add. WebRTC also uses User Datagram Protocol, or UDP, which is great for transmitting data really fast but more on that in a moment.</p><p><strong>So if webRTC is so fast, why use websockets at all?</strong></p><p>There are certain limitations with webRTC so typically using webRTC with websockets is more of a common practice.</p><p>First, webRTC uses UDP, and UDP is not a reliable protocol for transferring important data. UDP is good at sending data really fast but it doesn’t check whether or not the data is being received. So UDP is great for video because the data gets there fast and if we lose a few frames it’s not a big deal; but if this were a file we needed to send over and we lose a few bytes of data the entire file can be corrupted.</p><p>WebRTC also has no built-in signaling so it cant be used on its own to establish a peer to peer connection. WebRTC takes care of everything for us once the connection is established but leaves it up to us on how to transmit the initial data in order to connect two peers.</p><p><strong>So how does all of this work?</strong></p><p><img src=\"https://miro.medium.com/v2/resize:fit:875/0*8CIZHw7jhUcAqM96\" height=\"394\" width=\"700\"></p><p>From a high level perspective, to establish a connection, peer 1 will send some kind of message to peer 2 saying “hey, I want to connect to you, here’s some information about me and how you can connect to me, do you accept my offer?”</p><p>How this message is sent is irrelevant. This could be an email, a tweet OR you can signal it over to peer 2, it doesn’t matter, that parts up to you.</p><p>When peer 2 gets this information from peer 1, they have the opportunity to accept the connection. If peer 2 accepts, they will gather some information about their network and how to connect to it, and then send this information back to peer 1.</p><p>Once both peers have eachothers information, they are now connected and can now begin exchanging audio and video data or whatever else they want to send directly between their browsers without needing the server anymore.</p><p><strong>So what exactly is sent between the two clients and how is it sent?</strong></p><p>First off, how the information is sent is usually through a process called signaling. Since the two peers don’t know about each other we would typically have a way to bring them into a channel together using something like WebSockets or any third party signaling services.</p><p>Once we bring them into the same channel or room, they can now signal over their connection details. Those connection details come in the form of a session description protocol (SDP) and ICE candidates.</p><blockquote><strong><em>SDP&nbsp;</em></strong><em>— A Session Description Protocol (SDP), is an object containing information about the session connection such as the codec, address, media type, audio and video and so on. Both peers will exchange SDP’s so they can understand how to connect to each other. One in the form of an</em><strong><em>&nbsp;</em></strong><em>SDP Offer and another as an SDP Answer</em><strong><em>.</em></strong></blockquote><blockquote><strong><em>Ice Candidates</em></strong><em>&nbsp;— An ICE candidate is a public IP address and port that could potentially be an address that receives data. Each user will typically have multiple Ice candidates that are gathered by making a series of requests to a STUN server.</em></blockquote><p>Exchanging Session Description Protocols and ICE candidates</p><p><img src=\"https://miro.medium.com/v2/resize:fit:875/0*cVujHaI_uJlRKGbZ\" height=\"394\" width=\"700\"></p><p><strong>So here is the order in which things will play out.</strong></p><p>First the two peers will exchange SDP’s using some sort of signaling method. Once the two SDP’s are exchanged the peers are now connected, but still CANNOT transmit data yet.</p><p>In order to exchange data between two peers we still need to transmit the data.The problem here is that nowadays most devices sit behind firewalls and NAT devices, so to coordinate the discovery of our public IP addresses we use a method called ICE, which stands for Interactive Connectivity Establishment.</p><p>So in the background once SDP offers are exchanged each peer will then make a series of requests to a STUN server which will generate a list of ICE candidates to use. STUN servers are cheap and easy to maintain and because of that there are tons of free services you can use so you won’t have to worry about setting one up.</p><p>Once peer 1 gets these ICE candidates back from the STUN they will send them over to peer 2 and will let the network determine the best candidate to use. Peer 2 will do the same by requesting their ICE candidates and then sending them to peer 1.</p><p>When these candidates are exchanged and an optimal path is discovered data can begin to flow between the two peers.</p><p><strong>Trickling ICE Candidates</strong></p><p>There’s one problem with the process of retrieving ice candidates and that is that it can take time. So for this we commonly use a method called “Trickle ICE” which means that as we receive each ICE candidate from the STUN server we will simply send them over one by one, so they will “trickle in”.</p><p><strong>Seeing it in action</strong></p><p>I put together a live demo so you can see how the SDP transfer process works without a signaling server. With this live demo you’ll open two tabs side by side and create, then transfer and SDP offer and answer between two peers. We won’t have to deal with Trickling on ICE candidates since they will be added to the SDP offer on creation.</p>","coverImageUrl":"https://escribir.s3.eu-north-1.amazonaws.com/1730710814257_c13u3ik81i8","createdAt":"2024-11-04T09:00:16.666Z","heading":"How does WebRTC work?","reactions":[],"status":"published","tag":"WebSocket","updatedAt":"2024-11-04T09:00:16.666Z"},"level":"info","message":"Blogs fetched:","timestamp":"2024-11-20T10:36:12.497Z"}
{"level":"info","message":"Fetching all blogs","timestamp":"2024-11-20T10:36:12.564Z"}
{"0":{"__v":0,"_id":"6728de448569245cc7ef2a74","author_id":{"_id":"6703c069d7012c3ddb50b644","image":"https://res.cloudinary.com/djfhotv8n/image/upload/v1728299835/Escribir_Profile_Images/ocyxece9pbagrcwn55zl.jpg","username":"Kunujuzz"},"comments":[],"content":"<p><img src=\"https://www.freecodecamp.org/news/content/images/2023/06/A9vQ.gif\" alt=\"An animated Pinky Promise between two people\" height=\"225\" width=\"400\"><em style=\"color: var(--gray85);\">Image Credit:&nbsp;</em><a href=\"https://gifer.com/en/Pxwc\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: var(--gray90); background-color: transparent;\"><em>https://gifer.com</em></a></p><p>A promise is an assurance or guarantee that something will happen in the future. A person can promise another person a specific outcome or result. Promises are not limited to individuals, governments and organizations can also make promises. You have probably made a promise before.</p><p>With this assurance (promise) comes two possible outcomes–either fulfillment or failure. A promise is tied to an outcome that will show it is fulfilled. If that outcome does not happen, then the promise failed. A promise at the end must have one of these results.</p><p>In JavaScript, a Promise is an&nbsp;<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_objects\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: var(--gray90); background-color: transparent;\">object</a>&nbsp;that will produce a single value some time in the future. If the promise is successful, it will produce a resolved value, but if something goes wrong then it will produce a reason why the promise failed. The possible outcomes here are similar to that of promises in real life.</p><p>JavaScript promises can be in one of three possible states. These states indicate the progress of the promise. They are:</p><ul><li><em style=\"color: var(--gray85);\">pending</em>: This is the default state of a defined promise</li><li><em style=\"color: var(--gray85);\">fulfilled</em>: This is the state of a successful promise</li><li><em style=\"color: var(--gray85);\">rejected</em>: This is the state of a failed promise</li></ul><p>A promise goes from&nbsp;<em style=\"color: var(--gray85);\">pending</em>&nbsp;to&nbsp;<em style=\"color: var(--gray85);\">fulfilled</em>, or from&nbsp;<em style=\"color: var(--gray85);\">pending</em>&nbsp;to&nbsp;<em style=\"color: var(--gray85);\">rejected—</em>‘fulfilled’ and ‘rejected’ indicate the end of a promise.</p><p>From now on, this article will refer to a 'promise' as the JavaScript object.</p><h2><strong>How to Create a Promise in JavaScript</strong></h2><p>To create a promise, you need to create an instance object using the&nbsp;<code>Promise</code>&nbsp;constructor function. The&nbsp;<code>Promise</code>&nbsp;constructor function takes in one parameter. That parameter is a function that defines when to resolve the new promise, and optionally when to reject it.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise = new Promise((resolve, reject) =&gt; {\r\n  // Condition to resolve or reject the promise\r\n});\r\n</pre><p>For example, assume you want a promise to resolve after a timeout of two seconds. You can achieve this by writing it into the parameter of the constructor function.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise = new Promise((resolve, reject) =&gt; {\r\n  setTimeout(() =&gt; resolve(\"Done!\"), 2000);\r\n});\r\n</pre><p>In promises,&nbsp;<code>resolve</code>&nbsp;is a function with an optional parameter representing the resolved value. Also,&nbsp;<code>reject</code>&nbsp;is a function with an optional parameter representing the reason why the promise failed. In the example above, the resolved value of the promise is the string&nbsp;<code>'Done!'</code>.</p><p>Here is yet another example showing how you can resolve or reject a promise based on the conditions you set. In this example, the outcome of the promise is based on a random number the program generates.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise = new Promise((resolve, reject) =&gt; {\r\n  const num = Math.random();\r\n  if (num &gt;= 0.5) {\r\n    resolve(\"Promise is fulfilled!\");\r\n  } else {\r\n    reject(\"Promise failed!\");\r\n  }\r\n});\r\n</pre><p>From these examples, you can see that you have control over when to resolve or reject your promise and can tie it to a certain condition. With that, you have learned how to create a promise in JavaScript.</p><h2><strong>How to Attach a Callback to a Promise</strong></h2><p>To create a callback for a promise, you need to use the&nbsp;<code>.then()</code>&nbsp;method. This method takes in two callback functions. The first function runs if the promise is resolved, while the second function runs if the promise is rejected.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise = new Promise((resolve, reject) =&gt; {\r\n  const num = Math.random();\r\n  if (num &gt;= 0.5) {\r\n    resolve(\"Promise is fulfilled!\");\r\n  } else {\r\n    reject(\"Promise failed!\");\r\n  }\r\n});\r\n\r\nfunction handleResolve(value) {\r\n  console.log(value);\r\n}\r\n\r\nfunction handleReject(reason) {\r\n  console.error(reason);\r\n}\r\n\r\npromise.then(handleResolve, handleReject);\r\n// Promise is fulfilled!\r\n// or\r\n// Promise failed!\r\n</pre><p>That is the way to handle the possible outcomes of your promise. Any unhandled errors in your promise will keep them in a rejected state at the end but handled errors makes the operation return a fulfilled promise.</p><p>It is possible to create an immediately resolved promise, and then attach a callback with the&nbsp;<code>.then()</code>&nbsp;method. You can also create an immediately rejected promise in the same way too.</p><pre class=\"ql-syntax\" spellcheck=\"false\">Promise.resolve(\"Successful\").then((result) =&gt; console.log(result));\r\n// Successful\r\n\r\nPromise.reject(\"Not successful\").then((result) =&gt; console.log(result));\r\n// Error: Uncaught (in promise)\r\n</pre><p>The error in the rejected promise is because you need to define a separate callback to handle a rejected promise.</p><pre class=\"ql-syntax\" spellcheck=\"false\">Promise.reject(\"Not successful\").then(\r\n  () =&gt; {\r\n    /*Empty Callback if Promise is fulfilled*/\r\n  },\r\n  (reason) =&gt; console.error(reason)\r\n);\r\n// Not Successful\r\n</pre><p>Now you have properly handled a rejected outcome.</p><p>Promises make it incredibly easy to chain asynchronous instructions. When you handle a promise with the&nbsp;<code style=\"color: var(--gray85);\"><strong>.then()</strong></code>&nbsp;method, the operation always returns another promise. By employing this approach, you can eliminate the previously mentioned 'Callback Pyramid of Doom'.</p><p>Consider the code that previously caused the pyramid structure:</p><pre class=\"ql-syntax\" spellcheck=\"false\">fetchResource(\r\n  url,\r\n  function (result) {\r\n    // Do something with the result\r\n    fetchResource(\r\n      newUrl,\r\n      function (result) {\r\n        // Do something with the new result\r\n        fetchResource(\r\n          anotherUrl,\r\n          function (result) {\r\n            // Do something with the new result\r\n          },\r\n          failureCallback\r\n        );\r\n      },\r\n      failureCallback\r\n    );\r\n  },\r\n  failureCallback\r\n);\r\n</pre><p>However, because&nbsp;<code>.then()</code>&nbsp;returns another promise, this is how to write the same instructions above with promises:</p><pre class=\"ql-syntax\" spellcheck=\"false\">fetchResource(url)\r\n  .then(handleResult, failureCallback)\r\n  .then(handleNewResult, failureCallback)\r\n  .then(handleAnotherResult, failureCallback);\r\n</pre><p>As you can see, calling promises does not require a nested syntax. You can even eliminate the repeated&nbsp;<code>failureCallback</code>&nbsp;to make the code a lot neater, which is something the upcoming section of the article will explore.</p><h2><strong>How to Handle Errors in a Promise</strong></h2><p>To handle errors in Promises, use the&nbsp;<code>.catch()</code>&nbsp;method. If anything goes wrong with any of your promises, this method can catch the reason for that error.</p><pre class=\"ql-syntax\" spellcheck=\"false\">Promise.reject(new Error()).catch((reason) =&gt; console.error(reason));\r\n// Error\r\n</pre><p>This time in our example, the error output is no longer ‘uncaught’ because of&nbsp;<code>.catch()</code>.</p><p>You can also use the&nbsp;<code>.catch()</code>&nbsp;method in a chain of promises. It catches the first error it encounters in the chain.</p><p>For instance, refactoring the chain of promises following the&nbsp;<code>fetchResource()</code>&nbsp;function from the example of the previous section. This how you can stop error callback repetition in your code.</p><pre class=\"ql-syntax\" spellcheck=\"false\">fetchResource(url)\r\n  .then(handleResult)\r\n  .then(handleNewResult)\r\n  .then(handleAnotherResult)\r\n  .catch(failureCallback);\r\n</pre><p>You can also use&nbsp;<code>.catch()</code>&nbsp;to check for errors in a group of promises before proceeding with further asynchronous operations.</p><pre class=\"ql-syntax\" spellcheck=\"false\">fetchResource(url)\r\n  .then(handleResult)\r\n  .then(handleNewResult)\r\n  .catch(failureCallback)\r\n  // Check for Errors in the above group of promises before proceeding\r\n  .then(handleAnotherResult);\r\n</pre><p>The&nbsp;<code style=\"color: var(--gray85);\"><strong>.catch()</strong></code>&nbsp;method addresses any errors in a promise without requiring the nesting of error callback functions.</p><p>To chain an asynchronous operation to a promise regardless of if the promise is resolved or not, use the&nbsp;<code>.finally()</code>&nbsp;method. The&nbsp;<code>.then()</code>&nbsp;method is how you handle the results of a promise writing individual conditions for both resolved and rejected.&nbsp;<code>.catch()</code>&nbsp;runs only when there is an error. But sometimes you might want an operation to run no matter what happens to earlier promises.</p><p>Using&nbsp;<code>finally()</code>&nbsp;helps prevent possible code repetition in&nbsp;<code>.then()</code>&nbsp;and&nbsp;<code>.catch()</code>. It is for operations you must run whether there is an error or not.</p><pre class=\"ql-syntax\" spellcheck=\"false\">fetchResource(url)\r\n  .then(handleResult)\r\n  .then(handleNewResult)\r\n  .finally(onFinallyHandle);\r\n</pre><p>The&nbsp;<code>finally()</code>&nbsp;method has a few use cases in real-world applications. It is important if you want to perform cleanup operations for activities the promise initiated. Another use case—on Front-End Web Applications—is making user interface updates like stopping a loading spinner.</p><h2><strong>How to Handle Many Promises at Once</strong></h2><p>It is possible to run more than one promise at a time. All the examples you have seen so far are for promises that run one after the other.</p><p>In the previous examples, promises run similarly to synchronous code in the sense that they wait for the previous one to be resolved or rejected. But you could have multiple promises that run in parallel.</p><p>Here are the available methods that can help us achieve this:</p><ul><li><code>Promise.all()</code></li><li><code>Promise.race()</code></li><li><code>Promise.any()</code></li><li><code>Promise.allSettled()</code></li></ul><p>In this section of the article, we'll review these methods.</p><h3><strong>The&nbsp;</strong><code><strong>Promise.all()</strong></code><strong>&nbsp;method</strong></h3><p><code style=\"color: var(--gray85);\"><strong>Promise.all()</strong></code>&nbsp;accepts an array of promises as an argument but returns a single promise as the output. The single promise it returns resolves with an array of values if all the promises in the input array are fulfilled. The array&nbsp;<code>Promise.all()</code>&nbsp;resolves with will contain the resolve values of individual promises in the input array.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise1 = Promise.resolve(`First Promise's Value`);\r\nconst promise2 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 3000, `Second Promise's Value`)\r\n);\r\nconst promise3 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 2000, `Third Promise's Value`)\r\n);\r\n\r\nPromise.all([promise1, promise2, promise3]);\r\n\r\n// Output on the console\r\n\r\n// *Promise {&lt;fulfilled&gt;: Array(3)}*\r\n\r\nPromise.all([promise1, promise2, promise3]).then((values) =&gt; {\r\n  values.forEach((value) =&gt; console.log(value));\r\n});\r\n\r\n// Output on the console\r\n\r\n// First Promise's Value\r\n// Second Promise's Value\r\n// Third Promise's Value\r\n</pre><p>If at least one promise in the input array does not resolve,&nbsp;<code>Promise.all()</code>&nbsp;will return a rejected promise with a reason. The reason for the rejection will be the same as that of the first rejected promise in the input array.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise1 = Promise.resolve(`First Promise's Value`);\r\nconst promise2 = new Promise((resolve, reject) =&gt;\r\n  setTimeout(reject, 2000, `First reason for rejection`)\r\n);\r\nconst promise3 = new Promise((resolve, reject) =&gt;\r\n  setTimeout(reject, 3000, `Second reason for rejection`)\r\n);\r\n\r\nPromise.all([promise1, promise2, promise3]);\r\n\r\n// Output on the console\r\n\r\n// *Promise {&lt;rejected&gt;: \"First reason for rejection\"}*\r\n</pre><p><code>Promise.all()</code>&nbsp;will run all the input promises before it returns a value. But it does not run the promises one after the other–instead it runs them at the same time.</p><p>This is why the total time it would take&nbsp;<code>Promise.all()</code>&nbsp;to return a value is roughly the time it would take the longest promise in the array to finish.</p><p><img src=\"https://www.freecodecamp.org/news/content/images/2023/06/quickpoll.png\" alt=\"Illustration showing when Promise.all() will produce a value\" height=\"753\" width=\"960\"></p><p>Despite that, it has to finish running&nbsp;<em style=\"color: var(--gray85);\">all</em>&nbsp;the promises before it returns anything.</p><h3><strong>The&nbsp;</strong><code><strong>Promise.race()</strong></code><strong>&nbsp;method</strong></h3><p><code>Promise.race()</code>&nbsp;accepts an array of promises as an argument and returns a single promise as an output. The single promise it returns is the fastest promise to finish running—resolved or not. This means&nbsp;<code>Promise.race()</code>&nbsp;will return the promise with the shortest execution time in an array of promises.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise1 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 3000, `First Promise's Value`)\r\n);\r\nconst promise2 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 2000, `Second Promise's Value`)\r\n);\r\nconst promise3 = Promise.resolve(`Third Promise's Value`);\r\n\r\nPromise.race([promise1, promise2, promise3]);\r\n\r\n// Output on the console\r\n\r\n// *Promise {&lt;fulfilled&gt;: \"Third Promise's Value\"}*\r\n</pre><p>In the example above, because&nbsp;<code>promise3</code>&nbsp;is a promise that resolves on being created,&nbsp;<code>Promise.race()</code>&nbsp;returns it as the fastest. Just like other&nbsp;<code>Promise</code>&nbsp;methods the article discusses in this section, it runs the promises in parallel and not one after the other.</p><p>If the promise with the shortest execution time happens to be rejected with a reason,&nbsp;<code>Promise.race()</code>&nbsp;returns a rejected promise and the reason why the fastest promise was rejected.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise1 = Promise.reject(`Reason for rejection`);\r\nconst promise2 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 3000, `First resolved Promise`)\r\n);\r\nconst promise3 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 2000, `Second resolved Promise`)\r\n);\r\n\r\nPromise.race([promise1, promise2, promise3]);\r\n\r\n// Output on the console\r\n\r\n// *Promise {&lt;rejected&gt;: \"Reason for rejection\"}*\r\n</pre><p><img src=\"https://www.freecodecamp.org/news/content/images/2023/06/quickpoll--3-.png\" alt=\"Illustration showing when Promise.race() will produce a value\" height=\"772\" width=\"1040\"></p><p><code>Promise.race()</code>&nbsp;is useful for running a list of asynchronous operations but only needing the result of the fastest executed operation.</p><h3><strong>The&nbsp;</strong><code><strong>Promise.any()</strong></code><strong>&nbsp;method</strong></h3><p><code>Promise.any()</code>&nbsp;accepts an array of Promises as an argument but returns a single Promise as the output. The single promise it returns is the first resolved promise in the input array. This method waits for&nbsp;<em style=\"color: var(--gray85);\">any</em>&nbsp;promise in the array to be resolved and would immediately return it as the output.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise1 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 3000, `First Promise's Value`)\r\n);\r\nconst promise2 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 2000, `Second Promise's Value`)\r\n);\r\nconst promise3 = Promise.reject(`Third Promise's Value`);\r\n\r\nPromise.any([promise1, promise2, promise3]);\r\n\r\n// Output on the console\r\n\r\n// *Promise {&lt;fulfilled&gt;: \"Second Promise's Value\"}*\r\n</pre><p>From the above example,&nbsp;<code>promise1</code>&nbsp;will resolve after 3 seconds,&nbsp;<code>promise2</code>&nbsp;will resolve after 2 seconds, and&nbsp;<code>promise3</code>&nbsp;immediately rejects. Because&nbsp;<code>Promise.any()</code>&nbsp;is looking for the first successful promise, it returns&nbsp;<code>promise2</code>.&nbsp;<code>promise1</code>&nbsp;is a little bit late and so it's left behind.</p><p>If none of the promises in the array are resolved,&nbsp;<code style=\"color: var(--gray85);\"><strong>Promise.any()</strong></code>&nbsp;returns a rejected promise. This rejected promise contains a JavaScript array of reasons, where each reason corresponds with that of a promise from the input array.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise1 = new Promise((resolve, reject) =&gt;\r\n  setTimeout(reject, 3000, `First rejection reason`)\r\n);\r\nconst promise2 = new Promise((resolve, reject) =&gt;\r\n  setTimeout(reject, 2000, `Second rejection reason`)\r\n);\r\nconst promise3 = Promise.reject(`Third rejection reason`);\r\n\r\nPromise.any([promise1, promise2, promise3]);\r\n\r\n// Output on the console\r\n\r\n// *Promise {&lt;rejected&gt;: Aggregate Error: All Promises were rejected}*\r\n\r\nPromise.any([promise1, promise2, promise3]).catch(({ errors }) =&gt;\r\n  console.log(errors)\r\n);\r\n\r\n// Output on the console\r\n\r\n// *(3) [\"First* rejection reason*\", \"Second* rejection reason*\", \"Third* rejection reason*\"]*\r\n</pre><p>This method is useful for asynchronous operations where the fastest successful promise is all you need.&nbsp;<code>Promise.any()</code>&nbsp;and&nbsp;<code>Promise.race()</code>&nbsp;are similar, except that&nbsp;<code>Promise.any()</code>&nbsp;will return the fastest promise to complete and be resolved, while&nbsp;<code>Promise.race()</code>&nbsp;will return the fastest promise to complete and does not care if it is resolved or not.</p><p><br></p>","coverImageUrl":"https://escribir.s3.eu-north-1.amazonaws.com/1730731585593_lvpfnugwgoa","createdAt":"2024-11-04T14:46:28.066Z","heading":"What is a Promise?","reactions":[],"status":"published","tag":"JavaScript","updatedAt":"2024-11-09T05:21:12.915Z"},"1":{"__v":0,"_id":"6728abf41aec9bbaf4acfbf8","author_id":{"_id":"6719d873a7ce679095b76e01","image":"https://res.cloudinary.com/djfhotv8n/image/upload/v1729747676/Escribir_Profile_Images/ybc9vtwqaqnly2lkwjhu.jpg","username":"Sneha K"},"comments":[],"content":"<h2>Peace Starts When We Embrace Who We Are, Not Who We Should Be</h2><p><img src=\"https://cdn-images-1.readmedium.com/v2/resize:fit:800/1*3Vuj3LOBgHyrDZjmkU4Dig.png\">Image created by author using&nbsp;<a href=\"https://www.midjourney.com/app/\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: inherit;\">MidJourney</a></p><p><br></p><p><br></p><p><em>“You’re doing better than you think. Stop being so hard on yourself,”</em>&nbsp;I told my friend as he sat across from me, tears streaming down his face. His voice cracked as he repeated the words:&nbsp;<em>“I failed her. I’m not good enough. I’ll never be good enough.”&nbsp;</em>I didn’t know what else to say to him. Here was someone who had never truly accepted himself, no matter how much he accomplished.</p><p>My friend had built a multimillion-dollar business from nothing, rising out of poverty. He cared for his aging parents, sent two siblings to college, and even helped them get married — all before he turned forty. Yet, despite these incredible achievements, his response was always the same whenever I praised him:&nbsp;<em>“Not good enough. Not yet.”</em></p><p>I know this mindset well, having grown up in an entrepreneurial family where my performance was constantly measured through comparisons.<em>“Look at so-and-so’s son and how well he’s doing,”</em>&nbsp;my father would say. That sense of comparisons and expectations was relentless. The thought of meeting these standards blinded me to the 90% of things I was doing right. Instead, I became fixated on the never-ending 10% I hadn’t achieved to prove myself, and if not, I would become bitter toward myself and those I was trying to match in performance. I would develop an inflated self-confidence that I would crush all aspects of business or have zero to no confidence in certain business activities.</p><p>When I didn’t feel competitive enough, I lost opportunities and friendships when there was a better approach for collaboration and a win-win. I often didn’t know why I was competing; I just wanted to prove to my father that I was better than the other guy, and he was wrong. Initially, things might feel like you are improving and moving forward. Still, the amount of poison and negative energy you inject into yourself is much more damaging than the instant pleasure of the wins. At last, my father realized he was doing more damage than good when, during a fight, I told him, “How about you adopt one of those guys as your son, and I will find myself a better father?” It was a shock to him but a natural response from my side, being drained and always trying to follow his ideal image of the perfect son.</p><p>I have realized that one of our biggest mistakes when we don’t value ourselves is that we tie our self-worth to specific goals, metrics, or others’ constant demands and expectations. When we do that, falling short makes us feel worthless. We see ourselves as either winners or losers, with no middle ground. I had been there for a long time, and it took me countless reflections to understand that It’s tough to break free from this negative cycle unless I completely realize that my circumstances shaped my life. We all have our strengths and weaknesses and can control only so much.</p><p>My friend’s heartbreak wasn’t just about the end of his relationship; it was the overwhelming pressure he had placed on himself to be perfect in every part of his life. His girlfriend left because he was sometimes too focused on his business, not always free or mentally ready for her constant desire to hang out at social events with her friends. While he blamed himself, I knew he had always done his best given the circumstances.&nbsp;<em>“What more could you expect from yourself?”</em>&nbsp;I asked him.&nbsp;<em>“How else could you have acted within your conditions? Come on, man, at least give yourself credit for doing your best.”</em></p><p>His situation reminded me of my own struggles with self-acceptance. It took me a great deal of time to realize that self-acceptance doesn’t mean we must agree with everything we’ve done or be happy with every outcome. It simply means recognizing our efforts and staying true to ourselves. His girlfriend compared him to her friend’s boyfriends, men who might have far fewer responsibilities. Was that fair? Maybe not. He might not have been the perfect boyfriend, but he was doing his best with what life threw at him.</p><p>Through tears running down his face, he told me that night,&nbsp;<em>“I’m so tired. I don’t know what I did wrong. I gave everything I had. I don’t even know who I am anymore. Every day, I wake up trying to meet everyone’s expectations, and by the end of the day, I break into bed, exhausted. Yet, no matter what I do or how much I ‘fix’ myself, I still feel like I’m not good enough unless I meet their standards.”</em></p><p>“<em>That’s because you’re expecting happiness through changing your core to satisfy others,</em>” I told him. “<em>And no one can keep going with that for too long.</em>”</p><p>That conversation taught me a lesson I will never forget: the constant “go, go, go” mentality—the relentless craving to make everyone happy—comes at the cost of living in the present. We’re always chasing an idealized future of ourselves that never brings real happiness. We are constantly walking toward a mirage, only to find emptiness when we arrive, with a sign telling us to continue until we’re drained and broken by exhaustion.</p><p>In the past, I’ve also confused personal growth with self-acceptance, which has driven me to exhaustion in the name of “endless progress.” It’s natural to want more and to grow, but real change only happens when we acknowledge who we are despite the expectations of others or an ideal image of ourselves. Change can’t come from denying ourselves—denial leads to self-destruction. It traps us in a cycle of dwelling on past mistakes and constantly questioning our worth whenever we fall short of someone else’s standards.</p><p>At that conversation, I wished my friend could accept himself; I wish he didn’t blame himself for his past, and I wish he could live in the present and trust that despite his painful experiences, he could still grow and evolve in future relationships. Yes, his girlfriend might be wonderful, and he might be short on delivering sometimes, but maybe she wasn’t the right person for him at that point, which he realizes today.</p><p>Gladly, now he has changed his approach. Instead of trying to change himself entirely for someone, he is very open and transparent about his circumstances when he goes out on a date. It’s much happier to be honest and true to ourselves and find those who match and accept our circumstances than to change our cores to attract or maintain someone who is unwilling to see the committed part in us.</p><p><img src=\"https://cdn-images-1.readmedium.com/v2/resize:fit:800/1*-e_-zcnK0faNwbvMQonFCA.png\">Image created by author using&nbsp;<a href=\"https://www.midjourney.com/app/\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: inherit;\">MidJourney</a></p><p><br></p><p><br></p><p>Self-acceptance is difficult for many because it takes tremendous courage to be brutally honest with ourselves. It requires us to look at who we are without denial or avoidance. When we see the parts of ourselves that don’t measure up to someone else’s standards, we must also recognize the good in us — the beautiful qualities and positive force that contribute to the lives of others. That’s not easy when everyone holds you to expectations that make you feel unworthy the moment you fall short.</p><p>We all need to understand that individually we are whole beings, and collectively we paint the whole picture. You are not just a collection of good and bad parts — you are a complete person. You have strengths in certain areas, and the people you choose in life should complement you just as you complement them.</p><p>When you accept yourself and allow yourself to grow into your best form, you’ll realize that you only need to meet your natural and basic expectations, not anyone else’s. That’s when you begin to live authentically and give others the space to grow into their best selves within their abilities and circumstances.</p><p>That night, I told my friend, “<em>You don’t need all the answers right now, and that’s okay. Just understand that this is who you are, and this is your situation. Be at peace with that and move forward from there. The end of your relationship doesn’t mean you’re unlovable or incapable of giving love.</em>” I wasn’t asking him to ignore the pain or pretend nothing happened, but to acknowledge it without letting it define him. I encouraged him to see himself not as someone who failed but as someone who tried, learned, and is still standing despite it all, and today, he is finding more joy in his dating life.</p><p><br></p><p>One important lesson I’ve learned from painful experiences is to avoid comparing myself to others or being compared to anyone at any cost. I understand that life can be competitive, but comparison is not the right approach to growth. It’s the enemy of self-acceptance, breeding feelings of inadequacy. When we compare ourselves, we might create slightly better versions than others, but it comes at the expense of our authenticity. It traps us in a cycle of feeling worthless, never enough, and incapable. When we learn to see our authentic beauty, we also begin to see it in others without neglecting our self-worth. Others can inspire us, but we don’t need to become a copy of someone else in the name of improvement or to meet the demands of others.</p><p>Life teaches us that nature thrives in diversity. Each of its creations grows according to its strengths and circumstances. Denying the best in ourselves is denying the gifts life has given us. An oak tree doesn’t strive to become a smaller banana tree or a much larger mountain. It grows into its most natural and beautiful form, providing shade and strength for those who need it. That’s the essence of self-acceptance: it’s to become the best version of yourself, free from comparison. When you truly embrace that, everything else follows naturally.<strong>&nbsp;Cheers!</strong></p><p><br></p>","coverImageUrl":"https://escribir.s3.eu-north-1.amazonaws.com/1730718702669_aww8gabts9h","createdAt":"2024-11-04T11:11:48.729Z","heading":"When You Accept Yourself, Everything Else Falls Into Place","reactions":[],"status":"published","tag":"Self-Motivation","updatedAt":"2024-11-04T11:11:48.729Z"},"2":{"__v":0,"_id":"6728aaee1aec9bbaf4acfbe6","author_id":{"_id":"6719d873a7ce679095b76e01","image":"https://res.cloudinary.com/djfhotv8n/image/upload/v1729747676/Escribir_Profile_Images/ybc9vtwqaqnly2lkwjhu.jpg","username":"Sneha K"},"comments":[],"content":"<h2><br></h2><h1><br></h1><h1>How slowing down helped me move from burnout to clarity and finally discover the meaning behind my work and life</h1><h1><br></h1><p><img src=\"https://cdn-images-1.readmedium.com/v2/resize:fit:800/1*KGZwmYeby0MYf8E3pWnntA.png\">Image created by author using&nbsp;<a href=\"https://www.midjourney.com/app/\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: inherit;\">MidJourney</a></p><p><br></p><p><br></p><p><em>“I can’t stop! If I do, I’ll lose momentum, and everything I’ve built will fall apart!”</em>&nbsp;I replied in frustration.</p><p>My friend stared at me in confusion and said,&nbsp;<em>“What’s the point of it all if you’re the one falling apart?”</em></p><p><br></p><p><em><span class=\"ql-cursor\">﻿</span></em></p><p><strong>I froze. I had no answer!</strong></p><p>A few years ago, I believed that worthy accomplishment was defined by non-stop action. I thought the harder I pushed, the closer I’d get to the finish line of success. I assumed if I filled every second of my day with tasks and deadlines, I’d look and feel busy, and my goals would be achieved on autopilot.</p><p>But, in truth, I was driven by fear of falling behind. I was insecure and terrified of appearing lazy or like a procrastinator. I lived in megacities where more work was glorified, and constant busyness was a badge of discipline and focus. The problem was that the more I convinced myself I was doing the right thing, the more disconnected I became from myself. My behavior was making me less productive and even more ineffective. I spent time doing things but saw little to no noticeable return.</p><p>Looking back, I realize I left no room for reflection, no space to question whether I was doing things right. Pausing isn’t laziness; it’s wisdom. Stepping back from the noise and constant movement allows us to create space for clarity, reflection, and meaningful progress.</p><p>I often worked on projects for over 48 hours straight, with little to no sleep, forgetting and dismissing eating or even hydrating myself well. If you looked at my face, you’d see red eyes surrounded by dark circles — a zombie drained of energy. Like many of us, I, too, felt like everyone else was moving faster, and I couldn’t afford to stop. Pausing, to me, meant failure. I wish I’d known then that true success isn’t about how busy we are but about the intention behind our actions and the meaning behind our goals.</p><p>How many of us assume busyness gives us purpose? In reality, it steals our joy and clarity. We’re constantly driven by the need to prove ourselves, but in that pursuit, we forget that our well-being and happiness matter the most. When we don’t pause, breathe, and reflect, we never allow ourselves to realign with what truly matters. True accomplishment isn’t about how much we push — it’s about understanding when to take a step back and preventing ourselves from pushing too far into exhaustion</p><p>My attitude didn’t bring me the success I wanted. It led me to anxiety and depression. I became physically exhausted, mentally drained, and emotionally numb. Day after day, I watched my design proposals slip away to competitors who invested less effort but more “<strong>thoughtfulness</strong>.”</p><p>Mental health is a serious matter, and it made me stop. I was drained of energy and lacked motivation, even for the smallest tasks. My friends didn’t understand the situation and encouraged me to ignore my feelings and press on, but the harder I pushed, the more my mind and body fought back.</p><p>One night, I lost a design proposal I had spent so many days on and smashed my MacBook Pro against the wall. My ex-wife thought I was angry, but the underlying truth was I was desperate. I was hungry for success, yet my efforts yielded nothing. I listened to endless motivational videos to encourage myself, but practicality said otherwise.</p><p>The problem with the go-go-go mentality is that it fosters a scarcity mindset — do it now, or it’ll never happen. The truth is that opportunities will always exist, and we can achieve success if we slow down and think through our intentions.</p><p>My teacher in Shanghai, a wise, practical, and successful man in his 50s, captured this perfectly. One day, he told me, “<em>Maybe you are doing the right thing, but perhaps you are not doing it right. Learn to pause, move in small steps, and protect your well-being. Once you’re exhausted, it’s game over. People who aim to win know how to play longer while feeling their best.”</em></p><p>What he said was deep and true, many of us pursue the right goals, but our approach might be wrong. We put our relationships, mental health, and physical well-being at risk in the hope of achieving a future success that, to be honest, is unpredictable. We rush through everything and end up with nothing but exhaustion.</p><p>When we lose confidence, we think we’re not good enough for the job, when in reality, all we needed were moments of stillness to reflect and refill our energy. That’s why so many lose faith in themselves despite having the strength and talent to achieve their goals — if only they slowed down, contemplated, and took one small step at a time.</p><p>Burnout doesn’t happen overnight. I’ve experienced it countless times in my life. When we push ourselves beyond our limits, exhaustion becomes unavoidable. Once it takes hold, we lose clarity and purpose. What once felt meaningful becomes draining. Burnout is our spirit’s way of demanding that we need to stop.</p><p>At first, the idea of pausing and taking a step back was impossible to accept. It was completely uncomfortable because I thought I’d lose grip. It’s interesting when the brain is hooked on believing that more work equals greatness and rejects the thought of stepping away. The idea of turning off my computer, sitting on my balcony, or walking in the park without listening to a productivity book felt like proof of laziness.</p><p>What I forgot was that hardcore motivational talk is easy to say but, at times, impractical to follow. We’re human and vary in our energy levels, hormones, and emotions. There is a limit to how much we can push. I learned through experience that no matter how much guilt rushes through our minds, reminding us of what we “<strong>should</strong>” be doing, we’ll never feel like we’re doing enough — it’s human nature to want to achieve more and more.</p><p>But we forget that, at some point, our bodies will tire and push back. That’s when we have to stop, listen to our bodies, and root our sense of accomplishment in reality. Because even if we achieve materialistic success, without inner peace and moments of true relaxation, our lives will start to feel unbalanced, and the motivation and meaning we once had may begin to fade.</p><p><img src=\"https://cdn-images-1.readmedium.com/v2/resize:fit:800/1*qkct7UqT5UTJTTlpNo6YDg.png\">Image created by author using&nbsp;<a href=\"https://www.midjourney.com/app/\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: inherit;\">MidJourney</a></p><p><br></p><p><br></p><p>My first conscious step back happened when I left my phone at home and went for a walk in the park for an hour. At first, I was worried about missing messages. But then I paused and asked myself,<em>&nbsp;“What is wrong with you? You’ve been working non-stop for years, and you’ve gotten nowhere near your goals. Why do you think this one hour will make any difference?”</em></p><p>I realized I was looking busy all the time, but I wasn’t productive. I was just stuck behind my screen, eyeballs tracking the curser. When I assured myself that nothing would happen in that hour, I shifted my attention from the constant noise in my head urging me to keep overthinking about my work to the beauty of the world around me.</p><p>I noticed an elderly man who had brought a chicken to the park, letting kids play with it. Some cats in the park stared at the chicken, and a few even tried to chase it, but the man kept shooing them away. It was a joyful moment, and people laughed as they watched. The scene made me appreciate the beauty and vibrancy of the world around me, filling me with a sense of joy.</p><p>As I walked through the park, I felt the warmth of the sunlight, the breeze of fresh air, and the scent of beautiful Gardenia flowers. The tension in my muscles and the fogginess in my mind began to fade. My chest felt lighter, my breath deeper, and my thoughts clearer.</p><p>Many of us struggle with the silence that comes with stillness, but in these moments, we confront the truths buried under the weight of busyness. Learning to pause, even for small moments, helps us release what no longer serves us and discover a deeper sense of purpose. Clarity doesn’t come from doing more but from stepping back and creating space to think mindfully.</p><p>Pausing and reflecting have now become part of my daily routine. Whenever I feel myself rushing into work, I remind myself that this path only leads to burnout and exhaustion.</p><p>Sometimes, I call a friend and escape to a coffee shop or arcade for some lighthearted fun, stepping away from the constant pressure of work. These moments are important; they give me a much-needed break and allow my mind to reset.</p><p>During these moments of relaxation, I take the time to ask myself, What do I truly want? Why am I doing this? With greater clarity, I approach my work with intention, recognizing that if I’m not enjoying what I’m doing, it may not align with my passions. This realization often leads me to consider letting go of what no longer serves me and seeking out opportunities that better reflect my values. Once refreshed, I return feeling rejuvenated and ready to tackle my tasks with renewed energy.</p><p>There is a quote by John Lennon, “The time you enjoy wasting is not wasted time.” This quote resonates because pausing brings real value to our lives and is a wise use of time; it allows us to relax and act with intention, leading to more meaningful outcomes.</p><p>On the other hand, staying busy for the sake of it or rushing through projects without taking a moment to reflect on our goals and actions wastes both time and energy, often resulting in unclear aims and inefficient efforts. Pausing doesn’t mean losing momentum; it means gaining clarity and avoiding unnecessary mistakes. It allows us to approach tasks with a refreshed perspective, often leading to insights we might miss if we’re always in motion.</p><p>This change in my mindset has greatly helped me guide others toward clearer thinking as well. In my consulting business, when I see clients rushing, I urge them to slow down because, without thoughtfulness, we risk producing ineffective work that may need to be redone later. When they slow down and take the time to think about their decisions and actions, they approach tasks with more intention and ultimately appreciate the results of their careful investments — whether of time, effort, or money.</p><p><img src=\"https://cdn-images-1.readmedium.com/v2/resize:fit:800/1*IGU-4m4waL-tcb837JlbwQ.png\">Image created by author using&nbsp;<a href=\"https://www.midjourney.com/app/\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: inherit;\">MidJourney</a></p><p><br></p><p>This mindset adds “<strong>quality”</strong>&nbsp;to our lives — a concept we need to learn to embrace if we seek personal improvement. When we prioritize our mental, emotional, and physical health, everything else aligns harmoniously, allowing us to pursue our goals purposefully.</p><p>The world often demands continuous action, whether from work, relationships, or other commitments. When we fail to pause and recharge, it leads to burnout. Pausing shifts our focus from solely completing tasks to being present, allowing us to reflect on what truly matters in our lives. It allows us to consider our priorities and the relationships we value the most.</p><p>Next time you feel like you can’t stop, take a deep breath and&nbsp;<strong>ask yourself:&nbsp;</strong>What’s more important — blindly pushing forward or stepping back to find clarity? Are you moving with purpose or just keeping up with the pace? When we aim for peace, growth follows. Clarity emerges when you take a step back and trust that intention drives progress.&nbsp;<strong>Reflect on this:&nbsp;</strong>When given the choice, wouldn’t you prefer clarity over chaos? Here’s to choosing with intention.&nbsp;<strong>Cheers!</strong></p><p><br></p>","coverImageUrl":"https://escribir.s3.eu-north-1.amazonaws.com/1730718444147_v2tldzczzqq","createdAt":"2024-11-04T11:07:26.282Z","heading":"When You Pause, Your True Purpose Reveals Itself","reactions":[],"status":"published","tag":"Self-Motivation","updatedAt":"2024-11-04T11:07:26.282Z"},"3":{"__v":0,"_id":"6728a6761aec9bbaf4acfbd5","author_id":{"_id":"66ebecd0eb53f2be6b08101d","image":"https://res.cloudinary.com/djfhotv8n/image/upload/v1729616317/Escribir_Profile_Images/m4liuexkuts6xr6bdngp.jpg","username":"Jansiya jahan"},"comments":[],"content":"<h3><strong>Visual representations</strong></h3><p>I think it’s always good to start with some visualization.</p><p>Here are the most common pictures of this concept.</p><p><img src=\"https://cdn-media-1.freecodecamp.org/images/oVVbTLR5gXHgP8Ehlz1qzRm5LLjX9kv2Zri6\" alt=\"Image\" height=\"567\" width=\"772\"></p><p><img src=\"https://cdn-media-1.freecodecamp.org/images/YsN6twE3-4Q4OYpgxoModmx29I8zthQ3f0OR\" alt=\"Image\" height=\"400\" width=\"600\">_Source and credit: [https://www.codingblocks.net/podcast/clean-architecture-make-your-architecture-scream/](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html\" rel=\"noopener\" target=\"_blank\" title=\"\"&gt;https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html .&lt;a href=\"https://www.codingblocks.net/podcast/clean-architecture-make-your-architecture-scream/\" rel=\"noopener\" target=\"<em style=\"color: var(--gray85);\">blank\" title=\")</em></p><p><img src=\"https://cdn-media-1.freecodecamp.org/images/lbexLhWvRfpexSV0lSIWczkHd5KdszeDy9a3\" alt=\"Image\" height=\"400\" width=\"600\"></p><p><img src=\"https://cdn-media-1.freecodecamp.org/images/YIABVRTHRz58ZiT6W-emBkfNIQUHBelp8t6U\" alt=\"Image\" height=\"400\" width=\"600\">_Source and credit: Mattia Battiston, under CC BY 4.0, [https://github.com/mattia-battiston/clean-architecture-example](https://github.com/mattia-battiston/clean-architecture-example\" rel=\"noopener\" target=\"<em style=\"color: var(--gray85);\">blank\" title=\")</em></p><p><img src=\"https://cdn-media-1.freecodecamp.org/images/TmSQbZOg5bxn0cRXxIrRUd2zhqeDAXTe8ni5\" alt=\"Image\" height=\"400\" width=\"600\">_Source and credit: [https://marconijr.com/posts/clean-architecture-practice/](https://marconijr.com/posts/clean-architecture-practice/\" rel=\"noopener\" target=\"<em style=\"color: var(--gray85);\">blank\" title=\")</em></p><h3><strong>The concept — presented in bullet points</strong></h3><p>Extended from Source and credit:&nbsp;<a href=\"https://github.com/mattia-battiston/clean-architecture-example\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: var(--gray90); background-color: transparent;\">Mattia Battiston, under CC BY 4.0</a></p><h4><strong>The value it can provide</strong></h4><ul><li>An effective testing strategy that follows the testing pyramid</li><li>Frameworks are isolated in individual modules. When (not if) we change our mind, we only have to make a change in one place. The app has use cases rather than being tied to a CRUD system</li><li>Screaming architecture a.k.a. it screams its intended usage. When you look at the package structure, you get a feel for what the application does rather than seeing technical details</li><li>All business logic is in a use case, so it’s easy to find and not duplicated anywhere else</li><li>Hard to do the wrong thing because modules enforce compilation dependencies. If you try to use something that you’re not meant to, the app doesn’t compile</li><li>It is always ready to deploy by leaving the wiring up of the object for last. Or by using feature flags, so we get all the benefits of continuous integration</li><li>Multiple works on stories so that different pairs can easily work on the same story at the same time to complete it quicker</li><li>Good monolith with clear use cases that you can split in microservices later on, once you’ve learned more about them</li></ul><h4><strong>Entities</strong></h4><ul><li>Represent your domain object</li><li>Apply only logic that is applicable in general to the whole entity (e.g., validating the format of a hostname)</li><li>Plain objects: no frameworks, no annotations</li></ul><h4><strong>Use Cases</strong></h4><ul><li>Represent your business actions: it’s what you can do with the application. Expect one use case for each business action</li><li>Pure business logic, plain code (except maybe some utils libraries)</li><li>The use case doesn’t know who triggered it and how the results are going to be presented (for example, could be on a web page, or — returned as JSON, or simply logged, and so on.)</li><li>Throws business exceptions</li></ul><h4><strong>Interfaces / Adapters</strong></h4><ul><li>Retrieve and store data from and to a number of sources (database, network devices, file system, 3rd parties, and so on.)</li><li>Define interfaces for the data that they need in order to apply some logic. One or more data providers will implement the interface, but the use case doesn’t know where the data is coming from</li><li>Implement the interfaces defined by the use case</li><li>There are ways to interact with the application, and typically involve a delivery mechanism (for example, REST APIs, scheduled jobs, GUI, other systems)</li><li>Trigger a use case and convert the result to the appropriate format for the delivery mechanism</li><li>the controller for a MVC</li></ul><h4><strong>External Interfaces</strong></h4><ul><li>Use whatever framework is most appropriate (they are going to be isolated here anyway)</li></ul><h3><strong>Code example</strong></h3><p>See the structure on&nbsp;<a href=\"https://github.com/Createdd/web-miner/tree/master/webminer\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: var(--gray90); background-color: transparent;\">GitHub</a>.</p><p>First of all, it is important to understand that clean architecture is a bundle of organising principles. So therefore everything is open to personal adjustments as long as core ideas are kept intact. The linked repository is a fork of the original project that brought this architecture design idea to me. Feel free to check out the original project as well, as it reflects further improvements.</p><p>The webminer folder is structured into the basic layers:</p><ol><li>entities</li><li>use_cases</li><li>interfaces_adapters</li><li>external_interfaces</li></ol><p><img src=\"https://cdn-media-1.freecodecamp.org/images/FSvBm5GdWA0uMo6NJhyOoF2hgJt8s1Bv3n1v\" alt=\"Image\" height=\"400\" width=\"600\"><em style=\"color: var(--gray85);\">Structure of the webminer folder</em></p><p>It shall reflect the very basic approach for the design pattern.</p><ul><li>Starting from&nbsp;<code>entities</code>, you can see that the core model of this project is the&nbsp;<code>arxiv_document</code></li><li>The next folder,&nbsp;<code>use_cases</code>&nbsp;shows our use case, namely to request the arxiv page</li><li>After that, we go through the&nbsp;<code>interface_adapters</code>&nbsp;folder that provides adapters for process requests in a REST application or for serializing</li><li>The final and last layer is&nbsp;<code>external_interfaces</code>. This is where we use the flask server to implement the REST functionality</li></ul><p>All of those layers are dependent on the core layers but not the other way around.</p><p><strong style=\"color: var(--gray85);\">One important note: This is not 100% correctly implemented in the repository.</strong></p><p>Why? Because the use cases are actually different. In reality the main use case is to provide the structured data. Another use case is to get the data from the arxiv page.</p><p>Did you spot this error in the architecture? If yes, congratulations! Not only did you bring enough curiosity to this article but you likely understand the principles well enough to build your own case and apply the concepts in reality!</p><p>Do you agree? If not, why? Thanks for reading my article! Feel free to leave any feedback!</p>","coverImageUrl":"https://escribir.s3.eu-north-1.amazonaws.com/1730717299890_5yzadkrd3l5","createdAt":"2024-11-04T10:48:22.122Z","heading":"A quick introduction to clean architecture","reactions":[],"status":"published","tag":"JavaScript","updatedAt":"2024-11-04T10:48:22.122Z"},"4":{"__v":0,"_id":"6728a6291aec9bbaf4acfbcd","author_id":{"_id":"66ebecd0eb53f2be6b08101d","image":"https://res.cloudinary.com/djfhotv8n/image/upload/v1729616317/Escribir_Profile_Images/m4liuexkuts6xr6bdngp.jpg","username":"Jansiya jahan"},"comments":[],"content":"<p><span style=\"color: rgb(36, 36, 36);\">TypeScript is an open-source programming language developed by Microsoft. It is a statically typed superset of JavaScript, which means that any valid JavaScript code is also valid TypeScript code. However, TypeScript adds optional static typing and other features to help developers write more scalable and maintainable code. TypeScript and JavaScript are like brothers. As you know JavaScript was made in year of 1995 only in ten days it show how hurriedly in urgency they made this language so it have so many errors but now after so many upgrades its good to go. but now we have TypeScript which is more tackle-able as compared to JavaScript so in TypeScript</span></p><p><br></p><ul><li><span class=\"ql-cursor\">﻿</span>TypeScript&nbsp;<a href=\"https://www.youtube.com/redirect?event=video_description&amp;redir_token=QUFFLUhqbFFvT1ZkSnVYUllvZ0JPZTg5b2FmbkRBN3lOd3xBQ3Jtc0tubXkxQWo1SjNoelFjSTk4dnZvMXlkTEVNamp3WDNPYTlURzBfSXZXS2RtMmJHRmp0S2dLaHNjS25nVUFuNVlWdFdMWk1EUU1DQXBRVldTb3JWTk9Uc1lRcElkRmxpckZHVFgwYnFZWHducDdwNEdlMA&amp;q=https%3A%2F%2Fwww.typescriptlang.org%2Fdownload&amp;v=f3xeJOvqUPQ\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: inherit;\">https://www.typescriptlang.org/download</a></li></ul><p><br></p><p><span style=\"color: rgb(36, 36, 36);\"><img src=\"https://miro.medium.com/v2/resize:fit:708/1*-GCUmL0FbFSpT2SLa74P4Q.png\" alt=\"https://www.typescriptlang.org/download\" height=\"215\" width=\"566\"></span></p><p><span style=\"color: rgb(36, 36, 36);\">So here’s a breakdown of some key concepts in TypeScript:</span></p><ul><li>Static Typing: TypeScript allows you to specify types for variables, function parameters, return types, and more. This helps catch type-related errors during development and provides better tooling support for code editors.</li><li>Type Inference: TypeScript’s type inference system can often automatically infer types based on how you’ve written your code. This means you don’t always have to explicitly specify types, though you can if you want to be more explicit.</li><li>Interfaces and Types: TypeScript allows you to define custom types using interfaces and types. These can describe the shape of objects, including the types of their properties and methods.</li><li>Classes and Inheritance: TypeScript supports object-oriented programming features like classes, inheritance, and access modifiers (public, private, and protected).</li><li>Enums: TypeScript provides support for enums, which allow you to define a set of named constants. Enums are useful when you have a fixed set of values that a variable can take.</li><li>Generics: TypeScript supports generics, which allow you to write reusable code that can work with a variety of data types while still maintaining type safety.</li><li>Modules: TypeScript supports modular programming through the use of modules. You can import and export functionality between different files, which helps organize code and manage dependencies.</li></ul><p>Overall, TypeScript aims to make it easier to build large-scale JavaScript applications by adding features that help catch errors early, improve code maintainability, and provide better tooling support. It compiles down to plain JavaScript, through node.js it works as a compiler in between JS &amp; TS so it easily run on any JavaScript runtime, making it a versatile choice for web development.<span style=\"color: rgb(36, 36, 36);\">&nbsp;</span></p>","coverImageUrl":"https://escribir.s3.eu-north-1.amazonaws.com/1730717223118_5njbdoap6ps","createdAt":"2024-11-04T10:47:05.763Z","heading":"Introduction To TypeScript","reactions":[],"status":"published","tag":"TypeScript","updatedAt":"2024-11-04T10:47:05.763Z"},"5":{"__v":0,"_id":"67288d201aec9bbaf4acfb11","author_id":{"_id":"66ebecd0eb53f2be6b08101d","image":"https://res.cloudinary.com/djfhotv8n/image/upload/v1729616317/Escribir_Profile_Images/m4liuexkuts6xr6bdngp.jpg","username":"Jansiya jahan"},"comments":[],"content":"<p><img src=\"https://miro.medium.com/v2/resize:fit:875/0*kCfge4a9Xm0zyqcP\" height=\"394\" width=\"700\"></p><p><strong>First lets Define what WebRTC is</strong></p><p>WebRTC is a set of JavaScript API’s that allow us to establish a peer to peer connection between two browsers to exchange data such as audio and video, allowing us to create applications with audio and video calling features.</p><p>What makes WebRTC special is that once a connection is established; data can be transmitted directly between browsers in real time without touching the server.&nbsp;By bypassing the server we reduce latency since the data doesn’t have to go to the server first, this makes webRTC great for exchanging audio and video.</p><p>Full video tutorial: “<a href=\"https://youtu.be/8I2axE6j204\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: inherit;\">How Does WebRTC Work? | Crash Course</a>”</p><p><strong>WebRTC Vs WebSockets</strong></p><p>Before we talk about how all this works, let’s look at the comparison between WebRTC and WebSockets since I know a lot of you are thinking “this sounds a lot like WebSockets, so why do we need WebRTC?” or vice versa.</p><p><img src=\"https://miro.medium.com/v2/resize:fit:875/0*Own87NQd76MSw2hc\" height=\"308\" width=\"700\"></p><p>With websockets we can also establish a connection between peers to exchange data in real time, but this connection is between the client and server. So if I send a message to a peer, the message first goes to the server, then the server sends that message to the other peer. This exchange typically happens really fast so even though there is some latency, you probably wouldn’t even notice it if you’re sending something like a chat message or some kind of notification.</p><p>Now let’s say we wanted to exchange some audio or video using websockets, after all this is possible.</p><p>The problem here is that even the slightest latency when it comes to audio and video can be very noticeable and causes a lot of issues. So by the time your video data hits the server and back to your peer, you’re gonna see a significant delay.</p><p>This is where webRTC makes sense. By establishing a connection and exchanging data between two browsers we eliminate any delay that the server may add. WebRTC also uses User Datagram Protocol, or UDP, which is great for transmitting data really fast but more on that in a moment.</p><p><strong>So if webRTC is so fast, why use websockets at all?</strong></p><p>There are certain limitations with webRTC so typically using webRTC with websockets is more of a common practice.</p><p>First, webRTC uses UDP, and UDP is not a reliable protocol for transferring important data. UDP is good at sending data really fast but it doesn’t check whether or not the data is being received. So UDP is great for video because the data gets there fast and if we lose a few frames it’s not a big deal; but if this were a file we needed to send over and we lose a few bytes of data the entire file can be corrupted.</p><p>WebRTC also has no built-in signaling so it cant be used on its own to establish a peer to peer connection. WebRTC takes care of everything for us once the connection is established but leaves it up to us on how to transmit the initial data in order to connect two peers.</p><p><strong>So how does all of this work?</strong></p><p><img src=\"https://miro.medium.com/v2/resize:fit:875/0*8CIZHw7jhUcAqM96\" height=\"394\" width=\"700\"></p><p>From a high level perspective, to establish a connection, peer 1 will send some kind of message to peer 2 saying “hey, I want to connect to you, here’s some information about me and how you can connect to me, do you accept my offer?”</p><p>How this message is sent is irrelevant. This could be an email, a tweet OR you can signal it over to peer 2, it doesn’t matter, that parts up to you.</p><p>When peer 2 gets this information from peer 1, they have the opportunity to accept the connection. If peer 2 accepts, they will gather some information about their network and how to connect to it, and then send this information back to peer 1.</p><p>Once both peers have eachothers information, they are now connected and can now begin exchanging audio and video data or whatever else they want to send directly between their browsers without needing the server anymore.</p><p><strong>So what exactly is sent between the two clients and how is it sent?</strong></p><p>First off, how the information is sent is usually through a process called signaling. Since the two peers don’t know about each other we would typically have a way to bring them into a channel together using something like WebSockets or any third party signaling services.</p><p>Once we bring them into the same channel or room, they can now signal over their connection details. Those connection details come in the form of a session description protocol (SDP) and ICE candidates.</p><blockquote><strong><em>SDP&nbsp;</em></strong><em>— A Session Description Protocol (SDP), is an object containing information about the session connection such as the codec, address, media type, audio and video and so on. Both peers will exchange SDP’s so they can understand how to connect to each other. One in the form of an</em><strong><em>&nbsp;</em></strong><em>SDP Offer and another as an SDP Answer</em><strong><em>.</em></strong></blockquote><blockquote><strong><em>Ice Candidates</em></strong><em>&nbsp;— An ICE candidate is a public IP address and port that could potentially be an address that receives data. Each user will typically have multiple Ice candidates that are gathered by making a series of requests to a STUN server.</em></blockquote><p>Exchanging Session Description Protocols and ICE candidates</p><p><img src=\"https://miro.medium.com/v2/resize:fit:875/0*cVujHaI_uJlRKGbZ\" height=\"394\" width=\"700\"></p><p><strong>So here is the order in which things will play out.</strong></p><p>First the two peers will exchange SDP’s using some sort of signaling method. Once the two SDP’s are exchanged the peers are now connected, but still CANNOT transmit data yet.</p><p>In order to exchange data between two peers we still need to transmit the data.The problem here is that nowadays most devices sit behind firewalls and NAT devices, so to coordinate the discovery of our public IP addresses we use a method called ICE, which stands for Interactive Connectivity Establishment.</p><p>So in the background once SDP offers are exchanged each peer will then make a series of requests to a STUN server which will generate a list of ICE candidates to use. STUN servers are cheap and easy to maintain and because of that there are tons of free services you can use so you won’t have to worry about setting one up.</p><p>Once peer 1 gets these ICE candidates back from the STUN they will send them over to peer 2 and will let the network determine the best candidate to use. Peer 2 will do the same by requesting their ICE candidates and then sending them to peer 1.</p><p>When these candidates are exchanged and an optimal path is discovered data can begin to flow between the two peers.</p><p><strong>Trickling ICE Candidates</strong></p><p>There’s one problem with the process of retrieving ice candidates and that is that it can take time. So for this we commonly use a method called “Trickle ICE” which means that as we receive each ICE candidate from the STUN server we will simply send them over one by one, so they will “trickle in”.</p><p><strong>Seeing it in action</strong></p><p>I put together a live demo so you can see how the SDP transfer process works without a signaling server. With this live demo you’ll open two tabs side by side and create, then transfer and SDP offer and answer between two peers. We won’t have to deal with Trickling on ICE candidates since they will be added to the SDP offer on creation.</p>","coverImageUrl":"https://escribir.s3.eu-north-1.amazonaws.com/1730710814257_c13u3ik81i8","createdAt":"2024-11-04T09:00:16.666Z","heading":"How does WebRTC work?","reactions":[],"status":"published","tag":"WebSocket","updatedAt":"2024-11-04T09:00:16.666Z"},"level":"info","message":"Blogs fetched:","timestamp":"2024-11-20T10:36:12.780Z"}
{"level":"info","message":"Fetching single blog with ID:","timestamp":"2024-11-20T10:37:12.322Z"}
{"blog":{"__v":0,"_id":"6728de448569245cc7ef2a74","author_id":{"_id":"6703c069d7012c3ddb50b644","image":"https://res.cloudinary.com/djfhotv8n/image/upload/v1728299835/Escribir_Profile_Images/ocyxece9pbagrcwn55zl.jpg","username":"Kunujuzz"},"comments":[],"content":"<p><img src=\"https://www.freecodecamp.org/news/content/images/2023/06/A9vQ.gif\" alt=\"An animated Pinky Promise between two people\" height=\"225\" width=\"400\"><em style=\"color: var(--gray85);\">Image Credit:&nbsp;</em><a href=\"https://gifer.com/en/Pxwc\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: var(--gray90); background-color: transparent;\"><em>https://gifer.com</em></a></p><p>A promise is an assurance or guarantee that something will happen in the future. A person can promise another person a specific outcome or result. Promises are not limited to individuals, governments and organizations can also make promises. You have probably made a promise before.</p><p>With this assurance (promise) comes two possible outcomes–either fulfillment or failure. A promise is tied to an outcome that will show it is fulfilled. If that outcome does not happen, then the promise failed. A promise at the end must have one of these results.</p><p>In JavaScript, a Promise is an&nbsp;<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_objects\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: var(--gray90); background-color: transparent;\">object</a>&nbsp;that will produce a single value some time in the future. If the promise is successful, it will produce a resolved value, but if something goes wrong then it will produce a reason why the promise failed. The possible outcomes here are similar to that of promises in real life.</p><p>JavaScript promises can be in one of three possible states. These states indicate the progress of the promise. They are:</p><ul><li><em style=\"color: var(--gray85);\">pending</em>: This is the default state of a defined promise</li><li><em style=\"color: var(--gray85);\">fulfilled</em>: This is the state of a successful promise</li><li><em style=\"color: var(--gray85);\">rejected</em>: This is the state of a failed promise</li></ul><p>A promise goes from&nbsp;<em style=\"color: var(--gray85);\">pending</em>&nbsp;to&nbsp;<em style=\"color: var(--gray85);\">fulfilled</em>, or from&nbsp;<em style=\"color: var(--gray85);\">pending</em>&nbsp;to&nbsp;<em style=\"color: var(--gray85);\">rejected—</em>‘fulfilled’ and ‘rejected’ indicate the end of a promise.</p><p>From now on, this article will refer to a 'promise' as the JavaScript object.</p><h2><strong>How to Create a Promise in JavaScript</strong></h2><p>To create a promise, you need to create an instance object using the&nbsp;<code>Promise</code>&nbsp;constructor function. The&nbsp;<code>Promise</code>&nbsp;constructor function takes in one parameter. That parameter is a function that defines when to resolve the new promise, and optionally when to reject it.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise = new Promise((resolve, reject) =&gt; {\r\n  // Condition to resolve or reject the promise\r\n});\r\n</pre><p>For example, assume you want a promise to resolve after a timeout of two seconds. You can achieve this by writing it into the parameter of the constructor function.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise = new Promise((resolve, reject) =&gt; {\r\n  setTimeout(() =&gt; resolve(\"Done!\"), 2000);\r\n});\r\n</pre><p>In promises,&nbsp;<code>resolve</code>&nbsp;is a function with an optional parameter representing the resolved value. Also,&nbsp;<code>reject</code>&nbsp;is a function with an optional parameter representing the reason why the promise failed. In the example above, the resolved value of the promise is the string&nbsp;<code>'Done!'</code>.</p><p>Here is yet another example showing how you can resolve or reject a promise based on the conditions you set. In this example, the outcome of the promise is based on a random number the program generates.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise = new Promise((resolve, reject) =&gt; {\r\n  const num = Math.random();\r\n  if (num &gt;= 0.5) {\r\n    resolve(\"Promise is fulfilled!\");\r\n  } else {\r\n    reject(\"Promise failed!\");\r\n  }\r\n});\r\n</pre><p>From these examples, you can see that you have control over when to resolve or reject your promise and can tie it to a certain condition. With that, you have learned how to create a promise in JavaScript.</p><h2><strong>How to Attach a Callback to a Promise</strong></h2><p>To create a callback for a promise, you need to use the&nbsp;<code>.then()</code>&nbsp;method. This method takes in two callback functions. The first function runs if the promise is resolved, while the second function runs if the promise is rejected.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise = new Promise((resolve, reject) =&gt; {\r\n  const num = Math.random();\r\n  if (num &gt;= 0.5) {\r\n    resolve(\"Promise is fulfilled!\");\r\n  } else {\r\n    reject(\"Promise failed!\");\r\n  }\r\n});\r\n\r\nfunction handleResolve(value) {\r\n  console.log(value);\r\n}\r\n\r\nfunction handleReject(reason) {\r\n  console.error(reason);\r\n}\r\n\r\npromise.then(handleResolve, handleReject);\r\n// Promise is fulfilled!\r\n// or\r\n// Promise failed!\r\n</pre><p>That is the way to handle the possible outcomes of your promise. Any unhandled errors in your promise will keep them in a rejected state at the end but handled errors makes the operation return a fulfilled promise.</p><p>It is possible to create an immediately resolved promise, and then attach a callback with the&nbsp;<code>.then()</code>&nbsp;method. You can also create an immediately rejected promise in the same way too.</p><pre class=\"ql-syntax\" spellcheck=\"false\">Promise.resolve(\"Successful\").then((result) =&gt; console.log(result));\r\n// Successful\r\n\r\nPromise.reject(\"Not successful\").then((result) =&gt; console.log(result));\r\n// Error: Uncaught (in promise)\r\n</pre><p>The error in the rejected promise is because you need to define a separate callback to handle a rejected promise.</p><pre class=\"ql-syntax\" spellcheck=\"false\">Promise.reject(\"Not successful\").then(\r\n  () =&gt; {\r\n    /*Empty Callback if Promise is fulfilled*/\r\n  },\r\n  (reason) =&gt; console.error(reason)\r\n);\r\n// Not Successful\r\n</pre><p>Now you have properly handled a rejected outcome.</p><p>Promises make it incredibly easy to chain asynchronous instructions. When you handle a promise with the&nbsp;<code style=\"color: var(--gray85);\"><strong>.then()</strong></code>&nbsp;method, the operation always returns another promise. By employing this approach, you can eliminate the previously mentioned 'Callback Pyramid of Doom'.</p><p>Consider the code that previously caused the pyramid structure:</p><pre class=\"ql-syntax\" spellcheck=\"false\">fetchResource(\r\n  url,\r\n  function (result) {\r\n    // Do something with the result\r\n    fetchResource(\r\n      newUrl,\r\n      function (result) {\r\n        // Do something with the new result\r\n        fetchResource(\r\n          anotherUrl,\r\n          function (result) {\r\n            // Do something with the new result\r\n          },\r\n          failureCallback\r\n        );\r\n      },\r\n      failureCallback\r\n    );\r\n  },\r\n  failureCallback\r\n);\r\n</pre><p>However, because&nbsp;<code>.then()</code>&nbsp;returns another promise, this is how to write the same instructions above with promises:</p><pre class=\"ql-syntax\" spellcheck=\"false\">fetchResource(url)\r\n  .then(handleResult, failureCallback)\r\n  .then(handleNewResult, failureCallback)\r\n  .then(handleAnotherResult, failureCallback);\r\n</pre><p>As you can see, calling promises does not require a nested syntax. You can even eliminate the repeated&nbsp;<code>failureCallback</code>&nbsp;to make the code a lot neater, which is something the upcoming section of the article will explore.</p><h2><strong>How to Handle Errors in a Promise</strong></h2><p>To handle errors in Promises, use the&nbsp;<code>.catch()</code>&nbsp;method. If anything goes wrong with any of your promises, this method can catch the reason for that error.</p><pre class=\"ql-syntax\" spellcheck=\"false\">Promise.reject(new Error()).catch((reason) =&gt; console.error(reason));\r\n// Error\r\n</pre><p>This time in our example, the error output is no longer ‘uncaught’ because of&nbsp;<code>.catch()</code>.</p><p>You can also use the&nbsp;<code>.catch()</code>&nbsp;method in a chain of promises. It catches the first error it encounters in the chain.</p><p>For instance, refactoring the chain of promises following the&nbsp;<code>fetchResource()</code>&nbsp;function from the example of the previous section. This how you can stop error callback repetition in your code.</p><pre class=\"ql-syntax\" spellcheck=\"false\">fetchResource(url)\r\n  .then(handleResult)\r\n  .then(handleNewResult)\r\n  .then(handleAnotherResult)\r\n  .catch(failureCallback);\r\n</pre><p>You can also use&nbsp;<code>.catch()</code>&nbsp;to check for errors in a group of promises before proceeding with further asynchronous operations.</p><pre class=\"ql-syntax\" spellcheck=\"false\">fetchResource(url)\r\n  .then(handleResult)\r\n  .then(handleNewResult)\r\n  .catch(failureCallback)\r\n  // Check for Errors in the above group of promises before proceeding\r\n  .then(handleAnotherResult);\r\n</pre><p>The&nbsp;<code style=\"color: var(--gray85);\"><strong>.catch()</strong></code>&nbsp;method addresses any errors in a promise without requiring the nesting of error callback functions.</p><p>To chain an asynchronous operation to a promise regardless of if the promise is resolved or not, use the&nbsp;<code>.finally()</code>&nbsp;method. The&nbsp;<code>.then()</code>&nbsp;method is how you handle the results of a promise writing individual conditions for both resolved and rejected.&nbsp;<code>.catch()</code>&nbsp;runs only when there is an error. But sometimes you might want an operation to run no matter what happens to earlier promises.</p><p>Using&nbsp;<code>finally()</code>&nbsp;helps prevent possible code repetition in&nbsp;<code>.then()</code>&nbsp;and&nbsp;<code>.catch()</code>. It is for operations you must run whether there is an error or not.</p><pre class=\"ql-syntax\" spellcheck=\"false\">fetchResource(url)\r\n  .then(handleResult)\r\n  .then(handleNewResult)\r\n  .finally(onFinallyHandle);\r\n</pre><p>The&nbsp;<code>finally()</code>&nbsp;method has a few use cases in real-world applications. It is important if you want to perform cleanup operations for activities the promise initiated. Another use case—on Front-End Web Applications—is making user interface updates like stopping a loading spinner.</p><h2><strong>How to Handle Many Promises at Once</strong></h2><p>It is possible to run more than one promise at a time. All the examples you have seen so far are for promises that run one after the other.</p><p>In the previous examples, promises run similarly to synchronous code in the sense that they wait for the previous one to be resolved or rejected. But you could have multiple promises that run in parallel.</p><p>Here are the available methods that can help us achieve this:</p><ul><li><code>Promise.all()</code></li><li><code>Promise.race()</code></li><li><code>Promise.any()</code></li><li><code>Promise.allSettled()</code></li></ul><p>In this section of the article, we'll review these methods.</p><h3><strong>The&nbsp;</strong><code><strong>Promise.all()</strong></code><strong>&nbsp;method</strong></h3><p><code style=\"color: var(--gray85);\"><strong>Promise.all()</strong></code>&nbsp;accepts an array of promises as an argument but returns a single promise as the output. The single promise it returns resolves with an array of values if all the promises in the input array are fulfilled. The array&nbsp;<code>Promise.all()</code>&nbsp;resolves with will contain the resolve values of individual promises in the input array.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise1 = Promise.resolve(`First Promise's Value`);\r\nconst promise2 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 3000, `Second Promise's Value`)\r\n);\r\nconst promise3 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 2000, `Third Promise's Value`)\r\n);\r\n\r\nPromise.all([promise1, promise2, promise3]);\r\n\r\n// Output on the console\r\n\r\n// *Promise {&lt;fulfilled&gt;: Array(3)}*\r\n\r\nPromise.all([promise1, promise2, promise3]).then((values) =&gt; {\r\n  values.forEach((value) =&gt; console.log(value));\r\n});\r\n\r\n// Output on the console\r\n\r\n// First Promise's Value\r\n// Second Promise's Value\r\n// Third Promise's Value\r\n</pre><p>If at least one promise in the input array does not resolve,&nbsp;<code>Promise.all()</code>&nbsp;will return a rejected promise with a reason. The reason for the rejection will be the same as that of the first rejected promise in the input array.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise1 = Promise.resolve(`First Promise's Value`);\r\nconst promise2 = new Promise((resolve, reject) =&gt;\r\n  setTimeout(reject, 2000, `First reason for rejection`)\r\n);\r\nconst promise3 = new Promise((resolve, reject) =&gt;\r\n  setTimeout(reject, 3000, `Second reason for rejection`)\r\n);\r\n\r\nPromise.all([promise1, promise2, promise3]);\r\n\r\n// Output on the console\r\n\r\n// *Promise {&lt;rejected&gt;: \"First reason for rejection\"}*\r\n</pre><p><code>Promise.all()</code>&nbsp;will run all the input promises before it returns a value. But it does not run the promises one after the other–instead it runs them at the same time.</p><p>This is why the total time it would take&nbsp;<code>Promise.all()</code>&nbsp;to return a value is roughly the time it would take the longest promise in the array to finish.</p><p><img src=\"https://www.freecodecamp.org/news/content/images/2023/06/quickpoll.png\" alt=\"Illustration showing when Promise.all() will produce a value\" height=\"753\" width=\"960\"></p><p>Despite that, it has to finish running&nbsp;<em style=\"color: var(--gray85);\">all</em>&nbsp;the promises before it returns anything.</p><h3><strong>The&nbsp;</strong><code><strong>Promise.race()</strong></code><strong>&nbsp;method</strong></h3><p><code>Promise.race()</code>&nbsp;accepts an array of promises as an argument and returns a single promise as an output. The single promise it returns is the fastest promise to finish running—resolved or not. This means&nbsp;<code>Promise.race()</code>&nbsp;will return the promise with the shortest execution time in an array of promises.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise1 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 3000, `First Promise's Value`)\r\n);\r\nconst promise2 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 2000, `Second Promise's Value`)\r\n);\r\nconst promise3 = Promise.resolve(`Third Promise's Value`);\r\n\r\nPromise.race([promise1, promise2, promise3]);\r\n\r\n// Output on the console\r\n\r\n// *Promise {&lt;fulfilled&gt;: \"Third Promise's Value\"}*\r\n</pre><p>In the example above, because&nbsp;<code>promise3</code>&nbsp;is a promise that resolves on being created,&nbsp;<code>Promise.race()</code>&nbsp;returns it as the fastest. Just like other&nbsp;<code>Promise</code>&nbsp;methods the article discusses in this section, it runs the promises in parallel and not one after the other.</p><p>If the promise with the shortest execution time happens to be rejected with a reason,&nbsp;<code>Promise.race()</code>&nbsp;returns a rejected promise and the reason why the fastest promise was rejected.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise1 = Promise.reject(`Reason for rejection`);\r\nconst promise2 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 3000, `First resolved Promise`)\r\n);\r\nconst promise3 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 2000, `Second resolved Promise`)\r\n);\r\n\r\nPromise.race([promise1, promise2, promise3]);\r\n\r\n// Output on the console\r\n\r\n// *Promise {&lt;rejected&gt;: \"Reason for rejection\"}*\r\n</pre><p><img src=\"https://www.freecodecamp.org/news/content/images/2023/06/quickpoll--3-.png\" alt=\"Illustration showing when Promise.race() will produce a value\" height=\"772\" width=\"1040\"></p><p><code>Promise.race()</code>&nbsp;is useful for running a list of asynchronous operations but only needing the result of the fastest executed operation.</p><h3><strong>The&nbsp;</strong><code><strong>Promise.any()</strong></code><strong>&nbsp;method</strong></h3><p><code>Promise.any()</code>&nbsp;accepts an array of Promises as an argument but returns a single Promise as the output. The single promise it returns is the first resolved promise in the input array. This method waits for&nbsp;<em style=\"color: var(--gray85);\">any</em>&nbsp;promise in the array to be resolved and would immediately return it as the output.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise1 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 3000, `First Promise's Value`)\r\n);\r\nconst promise2 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 2000, `Second Promise's Value`)\r\n);\r\nconst promise3 = Promise.reject(`Third Promise's Value`);\r\n\r\nPromise.any([promise1, promise2, promise3]);\r\n\r\n// Output on the console\r\n\r\n// *Promise {&lt;fulfilled&gt;: \"Second Promise's Value\"}*\r\n</pre><p>From the above example,&nbsp;<code>promise1</code>&nbsp;will resolve after 3 seconds,&nbsp;<code>promise2</code>&nbsp;will resolve after 2 seconds, and&nbsp;<code>promise3</code>&nbsp;immediately rejects. Because&nbsp;<code>Promise.any()</code>&nbsp;is looking for the first successful promise, it returns&nbsp;<code>promise2</code>.&nbsp;<code>promise1</code>&nbsp;is a little bit late and so it's left behind.</p><p>If none of the promises in the array are resolved,&nbsp;<code style=\"color: var(--gray85);\"><strong>Promise.any()</strong></code>&nbsp;returns a rejected promise. This rejected promise contains a JavaScript array of reasons, where each reason corresponds with that of a promise from the input array.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise1 = new Promise((resolve, reject) =&gt;\r\n  setTimeout(reject, 3000, `First rejection reason`)\r\n);\r\nconst promise2 = new Promise((resolve, reject) =&gt;\r\n  setTimeout(reject, 2000, `Second rejection reason`)\r\n);\r\nconst promise3 = Promise.reject(`Third rejection reason`);\r\n\r\nPromise.any([promise1, promise2, promise3]);\r\n\r\n// Output on the console\r\n\r\n// *Promise {&lt;rejected&gt;: Aggregate Error: All Promises were rejected}*\r\n\r\nPromise.any([promise1, promise2, promise3]).catch(({ errors }) =&gt;\r\n  console.log(errors)\r\n);\r\n\r\n// Output on the console\r\n\r\n// *(3) [\"First* rejection reason*\", \"Second* rejection reason*\", \"Third* rejection reason*\"]*\r\n</pre><p>This method is useful for asynchronous operations where the fastest successful promise is all you need.&nbsp;<code>Promise.any()</code>&nbsp;and&nbsp;<code>Promise.race()</code>&nbsp;are similar, except that&nbsp;<code>Promise.any()</code>&nbsp;will return the fastest promise to complete and be resolved, while&nbsp;<code>Promise.race()</code>&nbsp;will return the fastest promise to complete and does not care if it is resolved or not.</p><p><br></p>","coverImageUrl":"https://escribir.s3.eu-north-1.amazonaws.com/1730731585593_lvpfnugwgoa","createdAt":"2024-11-04T14:46:28.066Z","heading":"What is a Promise?","reactions":[],"status":"published","tag":"JavaScript","updatedAt":"2024-11-09T05:21:12.915Z"},"level":"info","message":"Fetched single blog:","timestamp":"2024-11-20T10:37:12.547Z"}
{"level":"info","message":"Fetching single blog with ID:","timestamp":"2024-11-20T10:37:12.564Z"}
{"level":"info","message":"Fetching blogs for user with ID:","timestamp":"2024-11-20T10:37:12.654Z"}
{"blog":{"__v":0,"_id":"6728de448569245cc7ef2a74","author_id":{"_id":"6703c069d7012c3ddb50b644","image":"https://res.cloudinary.com/djfhotv8n/image/upload/v1728299835/Escribir_Profile_Images/ocyxece9pbagrcwn55zl.jpg","username":"Kunujuzz"},"comments":[],"content":"<p><img src=\"https://www.freecodecamp.org/news/content/images/2023/06/A9vQ.gif\" alt=\"An animated Pinky Promise between two people\" height=\"225\" width=\"400\"><em style=\"color: var(--gray85);\">Image Credit:&nbsp;</em><a href=\"https://gifer.com/en/Pxwc\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: var(--gray90); background-color: transparent;\"><em>https://gifer.com</em></a></p><p>A promise is an assurance or guarantee that something will happen in the future. A person can promise another person a specific outcome or result. Promises are not limited to individuals, governments and organizations can also make promises. You have probably made a promise before.</p><p>With this assurance (promise) comes two possible outcomes–either fulfillment or failure. A promise is tied to an outcome that will show it is fulfilled. If that outcome does not happen, then the promise failed. A promise at the end must have one of these results.</p><p>In JavaScript, a Promise is an&nbsp;<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_objects\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: var(--gray90); background-color: transparent;\">object</a>&nbsp;that will produce a single value some time in the future. If the promise is successful, it will produce a resolved value, but if something goes wrong then it will produce a reason why the promise failed. The possible outcomes here are similar to that of promises in real life.</p><p>JavaScript promises can be in one of three possible states. These states indicate the progress of the promise. They are:</p><ul><li><em style=\"color: var(--gray85);\">pending</em>: This is the default state of a defined promise</li><li><em style=\"color: var(--gray85);\">fulfilled</em>: This is the state of a successful promise</li><li><em style=\"color: var(--gray85);\">rejected</em>: This is the state of a failed promise</li></ul><p>A promise goes from&nbsp;<em style=\"color: var(--gray85);\">pending</em>&nbsp;to&nbsp;<em style=\"color: var(--gray85);\">fulfilled</em>, or from&nbsp;<em style=\"color: var(--gray85);\">pending</em>&nbsp;to&nbsp;<em style=\"color: var(--gray85);\">rejected—</em>‘fulfilled’ and ‘rejected’ indicate the end of a promise.</p><p>From now on, this article will refer to a 'promise' as the JavaScript object.</p><h2><strong>How to Create a Promise in JavaScript</strong></h2><p>To create a promise, you need to create an instance object using the&nbsp;<code>Promise</code>&nbsp;constructor function. The&nbsp;<code>Promise</code>&nbsp;constructor function takes in one parameter. That parameter is a function that defines when to resolve the new promise, and optionally when to reject it.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise = new Promise((resolve, reject) =&gt; {\r\n  // Condition to resolve or reject the promise\r\n});\r\n</pre><p>For example, assume you want a promise to resolve after a timeout of two seconds. You can achieve this by writing it into the parameter of the constructor function.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise = new Promise((resolve, reject) =&gt; {\r\n  setTimeout(() =&gt; resolve(\"Done!\"), 2000);\r\n});\r\n</pre><p>In promises,&nbsp;<code>resolve</code>&nbsp;is a function with an optional parameter representing the resolved value. Also,&nbsp;<code>reject</code>&nbsp;is a function with an optional parameter representing the reason why the promise failed. In the example above, the resolved value of the promise is the string&nbsp;<code>'Done!'</code>.</p><p>Here is yet another example showing how you can resolve or reject a promise based on the conditions you set. In this example, the outcome of the promise is based on a random number the program generates.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise = new Promise((resolve, reject) =&gt; {\r\n  const num = Math.random();\r\n  if (num &gt;= 0.5) {\r\n    resolve(\"Promise is fulfilled!\");\r\n  } else {\r\n    reject(\"Promise failed!\");\r\n  }\r\n});\r\n</pre><p>From these examples, you can see that you have control over when to resolve or reject your promise and can tie it to a certain condition. With that, you have learned how to create a promise in JavaScript.</p><h2><strong>How to Attach a Callback to a Promise</strong></h2><p>To create a callback for a promise, you need to use the&nbsp;<code>.then()</code>&nbsp;method. This method takes in two callback functions. The first function runs if the promise is resolved, while the second function runs if the promise is rejected.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise = new Promise((resolve, reject) =&gt; {\r\n  const num = Math.random();\r\n  if (num &gt;= 0.5) {\r\n    resolve(\"Promise is fulfilled!\");\r\n  } else {\r\n    reject(\"Promise failed!\");\r\n  }\r\n});\r\n\r\nfunction handleResolve(value) {\r\n  console.log(value);\r\n}\r\n\r\nfunction handleReject(reason) {\r\n  console.error(reason);\r\n}\r\n\r\npromise.then(handleResolve, handleReject);\r\n// Promise is fulfilled!\r\n// or\r\n// Promise failed!\r\n</pre><p>That is the way to handle the possible outcomes of your promise. Any unhandled errors in your promise will keep them in a rejected state at the end but handled errors makes the operation return a fulfilled promise.</p><p>It is possible to create an immediately resolved promise, and then attach a callback with the&nbsp;<code>.then()</code>&nbsp;method. You can also create an immediately rejected promise in the same way too.</p><pre class=\"ql-syntax\" spellcheck=\"false\">Promise.resolve(\"Successful\").then((result) =&gt; console.log(result));\r\n// Successful\r\n\r\nPromise.reject(\"Not successful\").then((result) =&gt; console.log(result));\r\n// Error: Uncaught (in promise)\r\n</pre><p>The error in the rejected promise is because you need to define a separate callback to handle a rejected promise.</p><pre class=\"ql-syntax\" spellcheck=\"false\">Promise.reject(\"Not successful\").then(\r\n  () =&gt; {\r\n    /*Empty Callback if Promise is fulfilled*/\r\n  },\r\n  (reason) =&gt; console.error(reason)\r\n);\r\n// Not Successful\r\n</pre><p>Now you have properly handled a rejected outcome.</p><p>Promises make it incredibly easy to chain asynchronous instructions. When you handle a promise with the&nbsp;<code style=\"color: var(--gray85);\"><strong>.then()</strong></code>&nbsp;method, the operation always returns another promise. By employing this approach, you can eliminate the previously mentioned 'Callback Pyramid of Doom'.</p><p>Consider the code that previously caused the pyramid structure:</p><pre class=\"ql-syntax\" spellcheck=\"false\">fetchResource(\r\n  url,\r\n  function (result) {\r\n    // Do something with the result\r\n    fetchResource(\r\n      newUrl,\r\n      function (result) {\r\n        // Do something with the new result\r\n        fetchResource(\r\n          anotherUrl,\r\n          function (result) {\r\n            // Do something with the new result\r\n          },\r\n          failureCallback\r\n        );\r\n      },\r\n      failureCallback\r\n    );\r\n  },\r\n  failureCallback\r\n);\r\n</pre><p>However, because&nbsp;<code>.then()</code>&nbsp;returns another promise, this is how to write the same instructions above with promises:</p><pre class=\"ql-syntax\" spellcheck=\"false\">fetchResource(url)\r\n  .then(handleResult, failureCallback)\r\n  .then(handleNewResult, failureCallback)\r\n  .then(handleAnotherResult, failureCallback);\r\n</pre><p>As you can see, calling promises does not require a nested syntax. You can even eliminate the repeated&nbsp;<code>failureCallback</code>&nbsp;to make the code a lot neater, which is something the upcoming section of the article will explore.</p><h2><strong>How to Handle Errors in a Promise</strong></h2><p>To handle errors in Promises, use the&nbsp;<code>.catch()</code>&nbsp;method. If anything goes wrong with any of your promises, this method can catch the reason for that error.</p><pre class=\"ql-syntax\" spellcheck=\"false\">Promise.reject(new Error()).catch((reason) =&gt; console.error(reason));\r\n// Error\r\n</pre><p>This time in our example, the error output is no longer ‘uncaught’ because of&nbsp;<code>.catch()</code>.</p><p>You can also use the&nbsp;<code>.catch()</code>&nbsp;method in a chain of promises. It catches the first error it encounters in the chain.</p><p>For instance, refactoring the chain of promises following the&nbsp;<code>fetchResource()</code>&nbsp;function from the example of the previous section. This how you can stop error callback repetition in your code.</p><pre class=\"ql-syntax\" spellcheck=\"false\">fetchResource(url)\r\n  .then(handleResult)\r\n  .then(handleNewResult)\r\n  .then(handleAnotherResult)\r\n  .catch(failureCallback);\r\n</pre><p>You can also use&nbsp;<code>.catch()</code>&nbsp;to check for errors in a group of promises before proceeding with further asynchronous operations.</p><pre class=\"ql-syntax\" spellcheck=\"false\">fetchResource(url)\r\n  .then(handleResult)\r\n  .then(handleNewResult)\r\n  .catch(failureCallback)\r\n  // Check for Errors in the above group of promises before proceeding\r\n  .then(handleAnotherResult);\r\n</pre><p>The&nbsp;<code style=\"color: var(--gray85);\"><strong>.catch()</strong></code>&nbsp;method addresses any errors in a promise without requiring the nesting of error callback functions.</p><p>To chain an asynchronous operation to a promise regardless of if the promise is resolved or not, use the&nbsp;<code>.finally()</code>&nbsp;method. The&nbsp;<code>.then()</code>&nbsp;method is how you handle the results of a promise writing individual conditions for both resolved and rejected.&nbsp;<code>.catch()</code>&nbsp;runs only when there is an error. But sometimes you might want an operation to run no matter what happens to earlier promises.</p><p>Using&nbsp;<code>finally()</code>&nbsp;helps prevent possible code repetition in&nbsp;<code>.then()</code>&nbsp;and&nbsp;<code>.catch()</code>. It is for operations you must run whether there is an error or not.</p><pre class=\"ql-syntax\" spellcheck=\"false\">fetchResource(url)\r\n  .then(handleResult)\r\n  .then(handleNewResult)\r\n  .finally(onFinallyHandle);\r\n</pre><p>The&nbsp;<code>finally()</code>&nbsp;method has a few use cases in real-world applications. It is important if you want to perform cleanup operations for activities the promise initiated. Another use case—on Front-End Web Applications—is making user interface updates like stopping a loading spinner.</p><h2><strong>How to Handle Many Promises at Once</strong></h2><p>It is possible to run more than one promise at a time. All the examples you have seen so far are for promises that run one after the other.</p><p>In the previous examples, promises run similarly to synchronous code in the sense that they wait for the previous one to be resolved or rejected. But you could have multiple promises that run in parallel.</p><p>Here are the available methods that can help us achieve this:</p><ul><li><code>Promise.all()</code></li><li><code>Promise.race()</code></li><li><code>Promise.any()</code></li><li><code>Promise.allSettled()</code></li></ul><p>In this section of the article, we'll review these methods.</p><h3><strong>The&nbsp;</strong><code><strong>Promise.all()</strong></code><strong>&nbsp;method</strong></h3><p><code style=\"color: var(--gray85);\"><strong>Promise.all()</strong></code>&nbsp;accepts an array of promises as an argument but returns a single promise as the output. The single promise it returns resolves with an array of values if all the promises in the input array are fulfilled. The array&nbsp;<code>Promise.all()</code>&nbsp;resolves with will contain the resolve values of individual promises in the input array.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise1 = Promise.resolve(`First Promise's Value`);\r\nconst promise2 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 3000, `Second Promise's Value`)\r\n);\r\nconst promise3 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 2000, `Third Promise's Value`)\r\n);\r\n\r\nPromise.all([promise1, promise2, promise3]);\r\n\r\n// Output on the console\r\n\r\n// *Promise {&lt;fulfilled&gt;: Array(3)}*\r\n\r\nPromise.all([promise1, promise2, promise3]).then((values) =&gt; {\r\n  values.forEach((value) =&gt; console.log(value));\r\n});\r\n\r\n// Output on the console\r\n\r\n// First Promise's Value\r\n// Second Promise's Value\r\n// Third Promise's Value\r\n</pre><p>If at least one promise in the input array does not resolve,&nbsp;<code>Promise.all()</code>&nbsp;will return a rejected promise with a reason. The reason for the rejection will be the same as that of the first rejected promise in the input array.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise1 = Promise.resolve(`First Promise's Value`);\r\nconst promise2 = new Promise((resolve, reject) =&gt;\r\n  setTimeout(reject, 2000, `First reason for rejection`)\r\n);\r\nconst promise3 = new Promise((resolve, reject) =&gt;\r\n  setTimeout(reject, 3000, `Second reason for rejection`)\r\n);\r\n\r\nPromise.all([promise1, promise2, promise3]);\r\n\r\n// Output on the console\r\n\r\n// *Promise {&lt;rejected&gt;: \"First reason for rejection\"}*\r\n</pre><p><code>Promise.all()</code>&nbsp;will run all the input promises before it returns a value. But it does not run the promises one after the other–instead it runs them at the same time.</p><p>This is why the total time it would take&nbsp;<code>Promise.all()</code>&nbsp;to return a value is roughly the time it would take the longest promise in the array to finish.</p><p><img src=\"https://www.freecodecamp.org/news/content/images/2023/06/quickpoll.png\" alt=\"Illustration showing when Promise.all() will produce a value\" height=\"753\" width=\"960\"></p><p>Despite that, it has to finish running&nbsp;<em style=\"color: var(--gray85);\">all</em>&nbsp;the promises before it returns anything.</p><h3><strong>The&nbsp;</strong><code><strong>Promise.race()</strong></code><strong>&nbsp;method</strong></h3><p><code>Promise.race()</code>&nbsp;accepts an array of promises as an argument and returns a single promise as an output. The single promise it returns is the fastest promise to finish running—resolved or not. This means&nbsp;<code>Promise.race()</code>&nbsp;will return the promise with the shortest execution time in an array of promises.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise1 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 3000, `First Promise's Value`)\r\n);\r\nconst promise2 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 2000, `Second Promise's Value`)\r\n);\r\nconst promise3 = Promise.resolve(`Third Promise's Value`);\r\n\r\nPromise.race([promise1, promise2, promise3]);\r\n\r\n// Output on the console\r\n\r\n// *Promise {&lt;fulfilled&gt;: \"Third Promise's Value\"}*\r\n</pre><p>In the example above, because&nbsp;<code>promise3</code>&nbsp;is a promise that resolves on being created,&nbsp;<code>Promise.race()</code>&nbsp;returns it as the fastest. Just like other&nbsp;<code>Promise</code>&nbsp;methods the article discusses in this section, it runs the promises in parallel and not one after the other.</p><p>If the promise with the shortest execution time happens to be rejected with a reason,&nbsp;<code>Promise.race()</code>&nbsp;returns a rejected promise and the reason why the fastest promise was rejected.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise1 = Promise.reject(`Reason for rejection`);\r\nconst promise2 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 3000, `First resolved Promise`)\r\n);\r\nconst promise3 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 2000, `Second resolved Promise`)\r\n);\r\n\r\nPromise.race([promise1, promise2, promise3]);\r\n\r\n// Output on the console\r\n\r\n// *Promise {&lt;rejected&gt;: \"Reason for rejection\"}*\r\n</pre><p><img src=\"https://www.freecodecamp.org/news/content/images/2023/06/quickpoll--3-.png\" alt=\"Illustration showing when Promise.race() will produce a value\" height=\"772\" width=\"1040\"></p><p><code>Promise.race()</code>&nbsp;is useful for running a list of asynchronous operations but only needing the result of the fastest executed operation.</p><h3><strong>The&nbsp;</strong><code><strong>Promise.any()</strong></code><strong>&nbsp;method</strong></h3><p><code>Promise.any()</code>&nbsp;accepts an array of Promises as an argument but returns a single Promise as the output. The single promise it returns is the first resolved promise in the input array. This method waits for&nbsp;<em style=\"color: var(--gray85);\">any</em>&nbsp;promise in the array to be resolved and would immediately return it as the output.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise1 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 3000, `First Promise's Value`)\r\n);\r\nconst promise2 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 2000, `Second Promise's Value`)\r\n);\r\nconst promise3 = Promise.reject(`Third Promise's Value`);\r\n\r\nPromise.any([promise1, promise2, promise3]);\r\n\r\n// Output on the console\r\n\r\n// *Promise {&lt;fulfilled&gt;: \"Second Promise's Value\"}*\r\n</pre><p>From the above example,&nbsp;<code>promise1</code>&nbsp;will resolve after 3 seconds,&nbsp;<code>promise2</code>&nbsp;will resolve after 2 seconds, and&nbsp;<code>promise3</code>&nbsp;immediately rejects. Because&nbsp;<code>Promise.any()</code>&nbsp;is looking for the first successful promise, it returns&nbsp;<code>promise2</code>.&nbsp;<code>promise1</code>&nbsp;is a little bit late and so it's left behind.</p><p>If none of the promises in the array are resolved,&nbsp;<code style=\"color: var(--gray85);\"><strong>Promise.any()</strong></code>&nbsp;returns a rejected promise. This rejected promise contains a JavaScript array of reasons, where each reason corresponds with that of a promise from the input array.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise1 = new Promise((resolve, reject) =&gt;\r\n  setTimeout(reject, 3000, `First rejection reason`)\r\n);\r\nconst promise2 = new Promise((resolve, reject) =&gt;\r\n  setTimeout(reject, 2000, `Second rejection reason`)\r\n);\r\nconst promise3 = Promise.reject(`Third rejection reason`);\r\n\r\nPromise.any([promise1, promise2, promise3]);\r\n\r\n// Output on the console\r\n\r\n// *Promise {&lt;rejected&gt;: Aggregate Error: All Promises were rejected}*\r\n\r\nPromise.any([promise1, promise2, promise3]).catch(({ errors }) =&gt;\r\n  console.log(errors)\r\n);\r\n\r\n// Output on the console\r\n\r\n// *(3) [\"First* rejection reason*\", \"Second* rejection reason*\", \"Third* rejection reason*\"]*\r\n</pre><p>This method is useful for asynchronous operations where the fastest successful promise is all you need.&nbsp;<code>Promise.any()</code>&nbsp;and&nbsp;<code>Promise.race()</code>&nbsp;are similar, except that&nbsp;<code>Promise.any()</code>&nbsp;will return the fastest promise to complete and be resolved, while&nbsp;<code>Promise.race()</code>&nbsp;will return the fastest promise to complete and does not care if it is resolved or not.</p><p><br></p>","coverImageUrl":"https://escribir.s3.eu-north-1.amazonaws.com/1730731585593_lvpfnugwgoa","createdAt":"2024-11-04T14:46:28.066Z","heading":"What is a Promise?","reactions":[],"status":"published","tag":"JavaScript","updatedAt":"2024-11-09T05:21:12.915Z"},"level":"info","message":"Fetched single blog:","timestamp":"2024-11-20T10:37:12.660Z"}
{"blogs":[{"__v":0,"_id":"6728de448569245cc7ef2a74","author_id":{"_id":"6703c069d7012c3ddb50b644","image":"https://res.cloudinary.com/djfhotv8n/image/upload/v1728299835/Escribir_Profile_Images/ocyxece9pbagrcwn55zl.jpg","username":"Kunujuzz"},"comments":[],"content":"<p><img src=\"https://www.freecodecamp.org/news/content/images/2023/06/A9vQ.gif\" alt=\"An animated Pinky Promise between two people\" height=\"225\" width=\"400\"><em style=\"color: var(--gray85);\">Image Credit:&nbsp;</em><a href=\"https://gifer.com/en/Pxwc\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: var(--gray90); background-color: transparent;\"><em>https://gifer.com</em></a></p><p>A promise is an assurance or guarantee that something will happen in the future. A person can promise another person a specific outcome or result. Promises are not limited to individuals, governments and organizations can also make promises. You have probably made a promise before.</p><p>With this assurance (promise) comes two possible outcomes–either fulfillment or failure. A promise is tied to an outcome that will show it is fulfilled. If that outcome does not happen, then the promise failed. A promise at the end must have one of these results.</p><p>In JavaScript, a Promise is an&nbsp;<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_objects\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: var(--gray90); background-color: transparent;\">object</a>&nbsp;that will produce a single value some time in the future. If the promise is successful, it will produce a resolved value, but if something goes wrong then it will produce a reason why the promise failed. The possible outcomes here are similar to that of promises in real life.</p><p>JavaScript promises can be in one of three possible states. These states indicate the progress of the promise. They are:</p><ul><li><em style=\"color: var(--gray85);\">pending</em>: This is the default state of a defined promise</li><li><em style=\"color: var(--gray85);\">fulfilled</em>: This is the state of a successful promise</li><li><em style=\"color: var(--gray85);\">rejected</em>: This is the state of a failed promise</li></ul><p>A promise goes from&nbsp;<em style=\"color: var(--gray85);\">pending</em>&nbsp;to&nbsp;<em style=\"color: var(--gray85);\">fulfilled</em>, or from&nbsp;<em style=\"color: var(--gray85);\">pending</em>&nbsp;to&nbsp;<em style=\"color: var(--gray85);\">rejected—</em>‘fulfilled’ and ‘rejected’ indicate the end of a promise.</p><p>From now on, this article will refer to a 'promise' as the JavaScript object.</p><h2><strong>How to Create a Promise in JavaScript</strong></h2><p>To create a promise, you need to create an instance object using the&nbsp;<code>Promise</code>&nbsp;constructor function. The&nbsp;<code>Promise</code>&nbsp;constructor function takes in one parameter. That parameter is a function that defines when to resolve the new promise, and optionally when to reject it.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise = new Promise((resolve, reject) =&gt; {\r\n  // Condition to resolve or reject the promise\r\n});\r\n</pre><p>For example, assume you want a promise to resolve after a timeout of two seconds. You can achieve this by writing it into the parameter of the constructor function.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise = new Promise((resolve, reject) =&gt; {\r\n  setTimeout(() =&gt; resolve(\"Done!\"), 2000);\r\n});\r\n</pre><p>In promises,&nbsp;<code>resolve</code>&nbsp;is a function with an optional parameter representing the resolved value. Also,&nbsp;<code>reject</code>&nbsp;is a function with an optional parameter representing the reason why the promise failed. In the example above, the resolved value of the promise is the string&nbsp;<code>'Done!'</code>.</p><p>Here is yet another example showing how you can resolve or reject a promise based on the conditions you set. In this example, the outcome of the promise is based on a random number the program generates.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise = new Promise((resolve, reject) =&gt; {\r\n  const num = Math.random();\r\n  if (num &gt;= 0.5) {\r\n    resolve(\"Promise is fulfilled!\");\r\n  } else {\r\n    reject(\"Promise failed!\");\r\n  }\r\n});\r\n</pre><p>From these examples, you can see that you have control over when to resolve or reject your promise and can tie it to a certain condition. With that, you have learned how to create a promise in JavaScript.</p><h2><strong>How to Attach a Callback to a Promise</strong></h2><p>To create a callback for a promise, you need to use the&nbsp;<code>.then()</code>&nbsp;method. This method takes in two callback functions. The first function runs if the promise is resolved, while the second function runs if the promise is rejected.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise = new Promise((resolve, reject) =&gt; {\r\n  const num = Math.random();\r\n  if (num &gt;= 0.5) {\r\n    resolve(\"Promise is fulfilled!\");\r\n  } else {\r\n    reject(\"Promise failed!\");\r\n  }\r\n});\r\n\r\nfunction handleResolve(value) {\r\n  console.log(value);\r\n}\r\n\r\nfunction handleReject(reason) {\r\n  console.error(reason);\r\n}\r\n\r\npromise.then(handleResolve, handleReject);\r\n// Promise is fulfilled!\r\n// or\r\n// Promise failed!\r\n</pre><p>That is the way to handle the possible outcomes of your promise. Any unhandled errors in your promise will keep them in a rejected state at the end but handled errors makes the operation return a fulfilled promise.</p><p>It is possible to create an immediately resolved promise, and then attach a callback with the&nbsp;<code>.then()</code>&nbsp;method. You can also create an immediately rejected promise in the same way too.</p><pre class=\"ql-syntax\" spellcheck=\"false\">Promise.resolve(\"Successful\").then((result) =&gt; console.log(result));\r\n// Successful\r\n\r\nPromise.reject(\"Not successful\").then((result) =&gt; console.log(result));\r\n// Error: Uncaught (in promise)\r\n</pre><p>The error in the rejected promise is because you need to define a separate callback to handle a rejected promise.</p><pre class=\"ql-syntax\" spellcheck=\"false\">Promise.reject(\"Not successful\").then(\r\n  () =&gt; {\r\n    /*Empty Callback if Promise is fulfilled*/\r\n  },\r\n  (reason) =&gt; console.error(reason)\r\n);\r\n// Not Successful\r\n</pre><p>Now you have properly handled a rejected outcome.</p><p>Promises make it incredibly easy to chain asynchronous instructions. When you handle a promise with the&nbsp;<code style=\"color: var(--gray85);\"><strong>.then()</strong></code>&nbsp;method, the operation always returns another promise. By employing this approach, you can eliminate the previously mentioned 'Callback Pyramid of Doom'.</p><p>Consider the code that previously caused the pyramid structure:</p><pre class=\"ql-syntax\" spellcheck=\"false\">fetchResource(\r\n  url,\r\n  function (result) {\r\n    // Do something with the result\r\n    fetchResource(\r\n      newUrl,\r\n      function (result) {\r\n        // Do something with the new result\r\n        fetchResource(\r\n          anotherUrl,\r\n          function (result) {\r\n            // Do something with the new result\r\n          },\r\n          failureCallback\r\n        );\r\n      },\r\n      failureCallback\r\n    );\r\n  },\r\n  failureCallback\r\n);\r\n</pre><p>However, because&nbsp;<code>.then()</code>&nbsp;returns another promise, this is how to write the same instructions above with promises:</p><pre class=\"ql-syntax\" spellcheck=\"false\">fetchResource(url)\r\n  .then(handleResult, failureCallback)\r\n  .then(handleNewResult, failureCallback)\r\n  .then(handleAnotherResult, failureCallback);\r\n</pre><p>As you can see, calling promises does not require a nested syntax. You can even eliminate the repeated&nbsp;<code>failureCallback</code>&nbsp;to make the code a lot neater, which is something the upcoming section of the article will explore.</p><h2><strong>How to Handle Errors in a Promise</strong></h2><p>To handle errors in Promises, use the&nbsp;<code>.catch()</code>&nbsp;method. If anything goes wrong with any of your promises, this method can catch the reason for that error.</p><pre class=\"ql-syntax\" spellcheck=\"false\">Promise.reject(new Error()).catch((reason) =&gt; console.error(reason));\r\n// Error\r\n</pre><p>This time in our example, the error output is no longer ‘uncaught’ because of&nbsp;<code>.catch()</code>.</p><p>You can also use the&nbsp;<code>.catch()</code>&nbsp;method in a chain of promises. It catches the first error it encounters in the chain.</p><p>For instance, refactoring the chain of promises following the&nbsp;<code>fetchResource()</code>&nbsp;function from the example of the previous section. This how you can stop error callback repetition in your code.</p><pre class=\"ql-syntax\" spellcheck=\"false\">fetchResource(url)\r\n  .then(handleResult)\r\n  .then(handleNewResult)\r\n  .then(handleAnotherResult)\r\n  .catch(failureCallback);\r\n</pre><p>You can also use&nbsp;<code>.catch()</code>&nbsp;to check for errors in a group of promises before proceeding with further asynchronous operations.</p><pre class=\"ql-syntax\" spellcheck=\"false\">fetchResource(url)\r\n  .then(handleResult)\r\n  .then(handleNewResult)\r\n  .catch(failureCallback)\r\n  // Check for Errors in the above group of promises before proceeding\r\n  .then(handleAnotherResult);\r\n</pre><p>The&nbsp;<code style=\"color: var(--gray85);\"><strong>.catch()</strong></code>&nbsp;method addresses any errors in a promise without requiring the nesting of error callback functions.</p><p>To chain an asynchronous operation to a promise regardless of if the promise is resolved or not, use the&nbsp;<code>.finally()</code>&nbsp;method. The&nbsp;<code>.then()</code>&nbsp;method is how you handle the results of a promise writing individual conditions for both resolved and rejected.&nbsp;<code>.catch()</code>&nbsp;runs only when there is an error. But sometimes you might want an operation to run no matter what happens to earlier promises.</p><p>Using&nbsp;<code>finally()</code>&nbsp;helps prevent possible code repetition in&nbsp;<code>.then()</code>&nbsp;and&nbsp;<code>.catch()</code>. It is for operations you must run whether there is an error or not.</p><pre class=\"ql-syntax\" spellcheck=\"false\">fetchResource(url)\r\n  .then(handleResult)\r\n  .then(handleNewResult)\r\n  .finally(onFinallyHandle);\r\n</pre><p>The&nbsp;<code>finally()</code>&nbsp;method has a few use cases in real-world applications. It is important if you want to perform cleanup operations for activities the promise initiated. Another use case—on Front-End Web Applications—is making user interface updates like stopping a loading spinner.</p><h2><strong>How to Handle Many Promises at Once</strong></h2><p>It is possible to run more than one promise at a time. All the examples you have seen so far are for promises that run one after the other.</p><p>In the previous examples, promises run similarly to synchronous code in the sense that they wait for the previous one to be resolved or rejected. But you could have multiple promises that run in parallel.</p><p>Here are the available methods that can help us achieve this:</p><ul><li><code>Promise.all()</code></li><li><code>Promise.race()</code></li><li><code>Promise.any()</code></li><li><code>Promise.allSettled()</code></li></ul><p>In this section of the article, we'll review these methods.</p><h3><strong>The&nbsp;</strong><code><strong>Promise.all()</strong></code><strong>&nbsp;method</strong></h3><p><code style=\"color: var(--gray85);\"><strong>Promise.all()</strong></code>&nbsp;accepts an array of promises as an argument but returns a single promise as the output. The single promise it returns resolves with an array of values if all the promises in the input array are fulfilled. The array&nbsp;<code>Promise.all()</code>&nbsp;resolves with will contain the resolve values of individual promises in the input array.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise1 = Promise.resolve(`First Promise's Value`);\r\nconst promise2 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 3000, `Second Promise's Value`)\r\n);\r\nconst promise3 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 2000, `Third Promise's Value`)\r\n);\r\n\r\nPromise.all([promise1, promise2, promise3]);\r\n\r\n// Output on the console\r\n\r\n// *Promise {&lt;fulfilled&gt;: Array(3)}*\r\n\r\nPromise.all([promise1, promise2, promise3]).then((values) =&gt; {\r\n  values.forEach((value) =&gt; console.log(value));\r\n});\r\n\r\n// Output on the console\r\n\r\n// First Promise's Value\r\n// Second Promise's Value\r\n// Third Promise's Value\r\n</pre><p>If at least one promise in the input array does not resolve,&nbsp;<code>Promise.all()</code>&nbsp;will return a rejected promise with a reason. The reason for the rejection will be the same as that of the first rejected promise in the input array.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise1 = Promise.resolve(`First Promise's Value`);\r\nconst promise2 = new Promise((resolve, reject) =&gt;\r\n  setTimeout(reject, 2000, `First reason for rejection`)\r\n);\r\nconst promise3 = new Promise((resolve, reject) =&gt;\r\n  setTimeout(reject, 3000, `Second reason for rejection`)\r\n);\r\n\r\nPromise.all([promise1, promise2, promise3]);\r\n\r\n// Output on the console\r\n\r\n// *Promise {&lt;rejected&gt;: \"First reason for rejection\"}*\r\n</pre><p><code>Promise.all()</code>&nbsp;will run all the input promises before it returns a value. But it does not run the promises one after the other–instead it runs them at the same time.</p><p>This is why the total time it would take&nbsp;<code>Promise.all()</code>&nbsp;to return a value is roughly the time it would take the longest promise in the array to finish.</p><p><img src=\"https://www.freecodecamp.org/news/content/images/2023/06/quickpoll.png\" alt=\"Illustration showing when Promise.all() will produce a value\" height=\"753\" width=\"960\"></p><p>Despite that, it has to finish running&nbsp;<em style=\"color: var(--gray85);\">all</em>&nbsp;the promises before it returns anything.</p><h3><strong>The&nbsp;</strong><code><strong>Promise.race()</strong></code><strong>&nbsp;method</strong></h3><p><code>Promise.race()</code>&nbsp;accepts an array of promises as an argument and returns a single promise as an output. The single promise it returns is the fastest promise to finish running—resolved or not. This means&nbsp;<code>Promise.race()</code>&nbsp;will return the promise with the shortest execution time in an array of promises.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise1 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 3000, `First Promise's Value`)\r\n);\r\nconst promise2 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 2000, `Second Promise's Value`)\r\n);\r\nconst promise3 = Promise.resolve(`Third Promise's Value`);\r\n\r\nPromise.race([promise1, promise2, promise3]);\r\n\r\n// Output on the console\r\n\r\n// *Promise {&lt;fulfilled&gt;: \"Third Promise's Value\"}*\r\n</pre><p>In the example above, because&nbsp;<code>promise3</code>&nbsp;is a promise that resolves on being created,&nbsp;<code>Promise.race()</code>&nbsp;returns it as the fastest. Just like other&nbsp;<code>Promise</code>&nbsp;methods the article discusses in this section, it runs the promises in parallel and not one after the other.</p><p>If the promise with the shortest execution time happens to be rejected with a reason,&nbsp;<code>Promise.race()</code>&nbsp;returns a rejected promise and the reason why the fastest promise was rejected.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise1 = Promise.reject(`Reason for rejection`);\r\nconst promise2 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 3000, `First resolved Promise`)\r\n);\r\nconst promise3 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 2000, `Second resolved Promise`)\r\n);\r\n\r\nPromise.race([promise1, promise2, promise3]);\r\n\r\n// Output on the console\r\n\r\n// *Promise {&lt;rejected&gt;: \"Reason for rejection\"}*\r\n</pre><p><img src=\"https://www.freecodecamp.org/news/content/images/2023/06/quickpoll--3-.png\" alt=\"Illustration showing when Promise.race() will produce a value\" height=\"772\" width=\"1040\"></p><p><code>Promise.race()</code>&nbsp;is useful for running a list of asynchronous operations but only needing the result of the fastest executed operation.</p><h3><strong>The&nbsp;</strong><code><strong>Promise.any()</strong></code><strong>&nbsp;method</strong></h3><p><code>Promise.any()</code>&nbsp;accepts an array of Promises as an argument but returns a single Promise as the output. The single promise it returns is the first resolved promise in the input array. This method waits for&nbsp;<em style=\"color: var(--gray85);\">any</em>&nbsp;promise in the array to be resolved and would immediately return it as the output.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise1 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 3000, `First Promise's Value`)\r\n);\r\nconst promise2 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 2000, `Second Promise's Value`)\r\n);\r\nconst promise3 = Promise.reject(`Third Promise's Value`);\r\n\r\nPromise.any([promise1, promise2, promise3]);\r\n\r\n// Output on the console\r\n\r\n// *Promise {&lt;fulfilled&gt;: \"Second Promise's Value\"}*\r\n</pre><p>From the above example,&nbsp;<code>promise1</code>&nbsp;will resolve after 3 seconds,&nbsp;<code>promise2</code>&nbsp;will resolve after 2 seconds, and&nbsp;<code>promise3</code>&nbsp;immediately rejects. Because&nbsp;<code>Promise.any()</code>&nbsp;is looking for the first successful promise, it returns&nbsp;<code>promise2</code>.&nbsp;<code>promise1</code>&nbsp;is a little bit late and so it's left behind.</p><p>If none of the promises in the array are resolved,&nbsp;<code style=\"color: var(--gray85);\"><strong>Promise.any()</strong></code>&nbsp;returns a rejected promise. This rejected promise contains a JavaScript array of reasons, where each reason corresponds with that of a promise from the input array.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise1 = new Promise((resolve, reject) =&gt;\r\n  setTimeout(reject, 3000, `First rejection reason`)\r\n);\r\nconst promise2 = new Promise((resolve, reject) =&gt;\r\n  setTimeout(reject, 2000, `Second rejection reason`)\r\n);\r\nconst promise3 = Promise.reject(`Third rejection reason`);\r\n\r\nPromise.any([promise1, promise2, promise3]);\r\n\r\n// Output on the console\r\n\r\n// *Promise {&lt;rejected&gt;: Aggregate Error: All Promises were rejected}*\r\n\r\nPromise.any([promise1, promise2, promise3]).catch(({ errors }) =&gt;\r\n  console.log(errors)\r\n);\r\n\r\n// Output on the console\r\n\r\n// *(3) [\"First* rejection reason*\", \"Second* rejection reason*\", \"Third* rejection reason*\"]*\r\n</pre><p>This method is useful for asynchronous operations where the fastest successful promise is all you need.&nbsp;<code>Promise.any()</code>&nbsp;and&nbsp;<code>Promise.race()</code>&nbsp;are similar, except that&nbsp;<code>Promise.any()</code>&nbsp;will return the fastest promise to complete and be resolved, while&nbsp;<code>Promise.race()</code>&nbsp;will return the fastest promise to complete and does not care if it is resolved or not.</p><p><br></p>","coverImageUrl":"https://escribir.s3.eu-north-1.amazonaws.com/1730731585593_lvpfnugwgoa","createdAt":"2024-11-04T14:46:28.066Z","heading":"What is a Promise?","reactions":[],"status":"published","tag":"JavaScript","updatedAt":"2024-11-09T05:21:12.915Z"}],"level":"info","message":"Fetched user blogs:","timestamp":"2024-11-20T10:37:12.954Z"}
{"level":"info","message":"Fetching all blogs","timestamp":"2024-11-20T10:37:18.010Z"}
{"0":{"__v":0,"_id":"6728de448569245cc7ef2a74","author_id":{"_id":"6703c069d7012c3ddb50b644","image":"https://res.cloudinary.com/djfhotv8n/image/upload/v1728299835/Escribir_Profile_Images/ocyxece9pbagrcwn55zl.jpg","username":"Kunujuzz"},"comments":[],"content":"<p><img src=\"https://www.freecodecamp.org/news/content/images/2023/06/A9vQ.gif\" alt=\"An animated Pinky Promise between two people\" height=\"225\" width=\"400\"><em style=\"color: var(--gray85);\">Image Credit:&nbsp;</em><a href=\"https://gifer.com/en/Pxwc\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: var(--gray90); background-color: transparent;\"><em>https://gifer.com</em></a></p><p>A promise is an assurance or guarantee that something will happen in the future. A person can promise another person a specific outcome or result. Promises are not limited to individuals, governments and organizations can also make promises. You have probably made a promise before.</p><p>With this assurance (promise) comes two possible outcomes–either fulfillment or failure. A promise is tied to an outcome that will show it is fulfilled. If that outcome does not happen, then the promise failed. A promise at the end must have one of these results.</p><p>In JavaScript, a Promise is an&nbsp;<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_objects\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: var(--gray90); background-color: transparent;\">object</a>&nbsp;that will produce a single value some time in the future. If the promise is successful, it will produce a resolved value, but if something goes wrong then it will produce a reason why the promise failed. The possible outcomes here are similar to that of promises in real life.</p><p>JavaScript promises can be in one of three possible states. These states indicate the progress of the promise. They are:</p><ul><li><em style=\"color: var(--gray85);\">pending</em>: This is the default state of a defined promise</li><li><em style=\"color: var(--gray85);\">fulfilled</em>: This is the state of a successful promise</li><li><em style=\"color: var(--gray85);\">rejected</em>: This is the state of a failed promise</li></ul><p>A promise goes from&nbsp;<em style=\"color: var(--gray85);\">pending</em>&nbsp;to&nbsp;<em style=\"color: var(--gray85);\">fulfilled</em>, or from&nbsp;<em style=\"color: var(--gray85);\">pending</em>&nbsp;to&nbsp;<em style=\"color: var(--gray85);\">rejected—</em>‘fulfilled’ and ‘rejected’ indicate the end of a promise.</p><p>From now on, this article will refer to a 'promise' as the JavaScript object.</p><h2><strong>How to Create a Promise in JavaScript</strong></h2><p>To create a promise, you need to create an instance object using the&nbsp;<code>Promise</code>&nbsp;constructor function. The&nbsp;<code>Promise</code>&nbsp;constructor function takes in one parameter. That parameter is a function that defines when to resolve the new promise, and optionally when to reject it.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise = new Promise((resolve, reject) =&gt; {\r\n  // Condition to resolve or reject the promise\r\n});\r\n</pre><p>For example, assume you want a promise to resolve after a timeout of two seconds. You can achieve this by writing it into the parameter of the constructor function.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise = new Promise((resolve, reject) =&gt; {\r\n  setTimeout(() =&gt; resolve(\"Done!\"), 2000);\r\n});\r\n</pre><p>In promises,&nbsp;<code>resolve</code>&nbsp;is a function with an optional parameter representing the resolved value. Also,&nbsp;<code>reject</code>&nbsp;is a function with an optional parameter representing the reason why the promise failed. In the example above, the resolved value of the promise is the string&nbsp;<code>'Done!'</code>.</p><p>Here is yet another example showing how you can resolve or reject a promise based on the conditions you set. In this example, the outcome of the promise is based on a random number the program generates.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise = new Promise((resolve, reject) =&gt; {\r\n  const num = Math.random();\r\n  if (num &gt;= 0.5) {\r\n    resolve(\"Promise is fulfilled!\");\r\n  } else {\r\n    reject(\"Promise failed!\");\r\n  }\r\n});\r\n</pre><p>From these examples, you can see that you have control over when to resolve or reject your promise and can tie it to a certain condition. With that, you have learned how to create a promise in JavaScript.</p><h2><strong>How to Attach a Callback to a Promise</strong></h2><p>To create a callback for a promise, you need to use the&nbsp;<code>.then()</code>&nbsp;method. This method takes in two callback functions. The first function runs if the promise is resolved, while the second function runs if the promise is rejected.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise = new Promise((resolve, reject) =&gt; {\r\n  const num = Math.random();\r\n  if (num &gt;= 0.5) {\r\n    resolve(\"Promise is fulfilled!\");\r\n  } else {\r\n    reject(\"Promise failed!\");\r\n  }\r\n});\r\n\r\nfunction handleResolve(value) {\r\n  console.log(value);\r\n}\r\n\r\nfunction handleReject(reason) {\r\n  console.error(reason);\r\n}\r\n\r\npromise.then(handleResolve, handleReject);\r\n// Promise is fulfilled!\r\n// or\r\n// Promise failed!\r\n</pre><p>That is the way to handle the possible outcomes of your promise. Any unhandled errors in your promise will keep them in a rejected state at the end but handled errors makes the operation return a fulfilled promise.</p><p>It is possible to create an immediately resolved promise, and then attach a callback with the&nbsp;<code>.then()</code>&nbsp;method. You can also create an immediately rejected promise in the same way too.</p><pre class=\"ql-syntax\" spellcheck=\"false\">Promise.resolve(\"Successful\").then((result) =&gt; console.log(result));\r\n// Successful\r\n\r\nPromise.reject(\"Not successful\").then((result) =&gt; console.log(result));\r\n// Error: Uncaught (in promise)\r\n</pre><p>The error in the rejected promise is because you need to define a separate callback to handle a rejected promise.</p><pre class=\"ql-syntax\" spellcheck=\"false\">Promise.reject(\"Not successful\").then(\r\n  () =&gt; {\r\n    /*Empty Callback if Promise is fulfilled*/\r\n  },\r\n  (reason) =&gt; console.error(reason)\r\n);\r\n// Not Successful\r\n</pre><p>Now you have properly handled a rejected outcome.</p><p>Promises make it incredibly easy to chain asynchronous instructions. When you handle a promise with the&nbsp;<code style=\"color: var(--gray85);\"><strong>.then()</strong></code>&nbsp;method, the operation always returns another promise. By employing this approach, you can eliminate the previously mentioned 'Callback Pyramid of Doom'.</p><p>Consider the code that previously caused the pyramid structure:</p><pre class=\"ql-syntax\" spellcheck=\"false\">fetchResource(\r\n  url,\r\n  function (result) {\r\n    // Do something with the result\r\n    fetchResource(\r\n      newUrl,\r\n      function (result) {\r\n        // Do something with the new result\r\n        fetchResource(\r\n          anotherUrl,\r\n          function (result) {\r\n            // Do something with the new result\r\n          },\r\n          failureCallback\r\n        );\r\n      },\r\n      failureCallback\r\n    );\r\n  },\r\n  failureCallback\r\n);\r\n</pre><p>However, because&nbsp;<code>.then()</code>&nbsp;returns another promise, this is how to write the same instructions above with promises:</p><pre class=\"ql-syntax\" spellcheck=\"false\">fetchResource(url)\r\n  .then(handleResult, failureCallback)\r\n  .then(handleNewResult, failureCallback)\r\n  .then(handleAnotherResult, failureCallback);\r\n</pre><p>As you can see, calling promises does not require a nested syntax. You can even eliminate the repeated&nbsp;<code>failureCallback</code>&nbsp;to make the code a lot neater, which is something the upcoming section of the article will explore.</p><h2><strong>How to Handle Errors in a Promise</strong></h2><p>To handle errors in Promises, use the&nbsp;<code>.catch()</code>&nbsp;method. If anything goes wrong with any of your promises, this method can catch the reason for that error.</p><pre class=\"ql-syntax\" spellcheck=\"false\">Promise.reject(new Error()).catch((reason) =&gt; console.error(reason));\r\n// Error\r\n</pre><p>This time in our example, the error output is no longer ‘uncaught’ because of&nbsp;<code>.catch()</code>.</p><p>You can also use the&nbsp;<code>.catch()</code>&nbsp;method in a chain of promises. It catches the first error it encounters in the chain.</p><p>For instance, refactoring the chain of promises following the&nbsp;<code>fetchResource()</code>&nbsp;function from the example of the previous section. This how you can stop error callback repetition in your code.</p><pre class=\"ql-syntax\" spellcheck=\"false\">fetchResource(url)\r\n  .then(handleResult)\r\n  .then(handleNewResult)\r\n  .then(handleAnotherResult)\r\n  .catch(failureCallback);\r\n</pre><p>You can also use&nbsp;<code>.catch()</code>&nbsp;to check for errors in a group of promises before proceeding with further asynchronous operations.</p><pre class=\"ql-syntax\" spellcheck=\"false\">fetchResource(url)\r\n  .then(handleResult)\r\n  .then(handleNewResult)\r\n  .catch(failureCallback)\r\n  // Check for Errors in the above group of promises before proceeding\r\n  .then(handleAnotherResult);\r\n</pre><p>The&nbsp;<code style=\"color: var(--gray85);\"><strong>.catch()</strong></code>&nbsp;method addresses any errors in a promise without requiring the nesting of error callback functions.</p><p>To chain an asynchronous operation to a promise regardless of if the promise is resolved or not, use the&nbsp;<code>.finally()</code>&nbsp;method. The&nbsp;<code>.then()</code>&nbsp;method is how you handle the results of a promise writing individual conditions for both resolved and rejected.&nbsp;<code>.catch()</code>&nbsp;runs only when there is an error. But sometimes you might want an operation to run no matter what happens to earlier promises.</p><p>Using&nbsp;<code>finally()</code>&nbsp;helps prevent possible code repetition in&nbsp;<code>.then()</code>&nbsp;and&nbsp;<code>.catch()</code>. It is for operations you must run whether there is an error or not.</p><pre class=\"ql-syntax\" spellcheck=\"false\">fetchResource(url)\r\n  .then(handleResult)\r\n  .then(handleNewResult)\r\n  .finally(onFinallyHandle);\r\n</pre><p>The&nbsp;<code>finally()</code>&nbsp;method has a few use cases in real-world applications. It is important if you want to perform cleanup operations for activities the promise initiated. Another use case—on Front-End Web Applications—is making user interface updates like stopping a loading spinner.</p><h2><strong>How to Handle Many Promises at Once</strong></h2><p>It is possible to run more than one promise at a time. All the examples you have seen so far are for promises that run one after the other.</p><p>In the previous examples, promises run similarly to synchronous code in the sense that they wait for the previous one to be resolved or rejected. But you could have multiple promises that run in parallel.</p><p>Here are the available methods that can help us achieve this:</p><ul><li><code>Promise.all()</code></li><li><code>Promise.race()</code></li><li><code>Promise.any()</code></li><li><code>Promise.allSettled()</code></li></ul><p>In this section of the article, we'll review these methods.</p><h3><strong>The&nbsp;</strong><code><strong>Promise.all()</strong></code><strong>&nbsp;method</strong></h3><p><code style=\"color: var(--gray85);\"><strong>Promise.all()</strong></code>&nbsp;accepts an array of promises as an argument but returns a single promise as the output. The single promise it returns resolves with an array of values if all the promises in the input array are fulfilled. The array&nbsp;<code>Promise.all()</code>&nbsp;resolves with will contain the resolve values of individual promises in the input array.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise1 = Promise.resolve(`First Promise's Value`);\r\nconst promise2 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 3000, `Second Promise's Value`)\r\n);\r\nconst promise3 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 2000, `Third Promise's Value`)\r\n);\r\n\r\nPromise.all([promise1, promise2, promise3]);\r\n\r\n// Output on the console\r\n\r\n// *Promise {&lt;fulfilled&gt;: Array(3)}*\r\n\r\nPromise.all([promise1, promise2, promise3]).then((values) =&gt; {\r\n  values.forEach((value) =&gt; console.log(value));\r\n});\r\n\r\n// Output on the console\r\n\r\n// First Promise's Value\r\n// Second Promise's Value\r\n// Third Promise's Value\r\n</pre><p>If at least one promise in the input array does not resolve,&nbsp;<code>Promise.all()</code>&nbsp;will return a rejected promise with a reason. The reason for the rejection will be the same as that of the first rejected promise in the input array.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise1 = Promise.resolve(`First Promise's Value`);\r\nconst promise2 = new Promise((resolve, reject) =&gt;\r\n  setTimeout(reject, 2000, `First reason for rejection`)\r\n);\r\nconst promise3 = new Promise((resolve, reject) =&gt;\r\n  setTimeout(reject, 3000, `Second reason for rejection`)\r\n);\r\n\r\nPromise.all([promise1, promise2, promise3]);\r\n\r\n// Output on the console\r\n\r\n// *Promise {&lt;rejected&gt;: \"First reason for rejection\"}*\r\n</pre><p><code>Promise.all()</code>&nbsp;will run all the input promises before it returns a value. But it does not run the promises one after the other–instead it runs them at the same time.</p><p>This is why the total time it would take&nbsp;<code>Promise.all()</code>&nbsp;to return a value is roughly the time it would take the longest promise in the array to finish.</p><p><img src=\"https://www.freecodecamp.org/news/content/images/2023/06/quickpoll.png\" alt=\"Illustration showing when Promise.all() will produce a value\" height=\"753\" width=\"960\"></p><p>Despite that, it has to finish running&nbsp;<em style=\"color: var(--gray85);\">all</em>&nbsp;the promises before it returns anything.</p><h3><strong>The&nbsp;</strong><code><strong>Promise.race()</strong></code><strong>&nbsp;method</strong></h3><p><code>Promise.race()</code>&nbsp;accepts an array of promises as an argument and returns a single promise as an output. The single promise it returns is the fastest promise to finish running—resolved or not. This means&nbsp;<code>Promise.race()</code>&nbsp;will return the promise with the shortest execution time in an array of promises.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise1 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 3000, `First Promise's Value`)\r\n);\r\nconst promise2 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 2000, `Second Promise's Value`)\r\n);\r\nconst promise3 = Promise.resolve(`Third Promise's Value`);\r\n\r\nPromise.race([promise1, promise2, promise3]);\r\n\r\n// Output on the console\r\n\r\n// *Promise {&lt;fulfilled&gt;: \"Third Promise's Value\"}*\r\n</pre><p>In the example above, because&nbsp;<code>promise3</code>&nbsp;is a promise that resolves on being created,&nbsp;<code>Promise.race()</code>&nbsp;returns it as the fastest. Just like other&nbsp;<code>Promise</code>&nbsp;methods the article discusses in this section, it runs the promises in parallel and not one after the other.</p><p>If the promise with the shortest execution time happens to be rejected with a reason,&nbsp;<code>Promise.race()</code>&nbsp;returns a rejected promise and the reason why the fastest promise was rejected.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise1 = Promise.reject(`Reason for rejection`);\r\nconst promise2 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 3000, `First resolved Promise`)\r\n);\r\nconst promise3 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 2000, `Second resolved Promise`)\r\n);\r\n\r\nPromise.race([promise1, promise2, promise3]);\r\n\r\n// Output on the console\r\n\r\n// *Promise {&lt;rejected&gt;: \"Reason for rejection\"}*\r\n</pre><p><img src=\"https://www.freecodecamp.org/news/content/images/2023/06/quickpoll--3-.png\" alt=\"Illustration showing when Promise.race() will produce a value\" height=\"772\" width=\"1040\"></p><p><code>Promise.race()</code>&nbsp;is useful for running a list of asynchronous operations but only needing the result of the fastest executed operation.</p><h3><strong>The&nbsp;</strong><code><strong>Promise.any()</strong></code><strong>&nbsp;method</strong></h3><p><code>Promise.any()</code>&nbsp;accepts an array of Promises as an argument but returns a single Promise as the output. The single promise it returns is the first resolved promise in the input array. This method waits for&nbsp;<em style=\"color: var(--gray85);\">any</em>&nbsp;promise in the array to be resolved and would immediately return it as the output.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise1 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 3000, `First Promise's Value`)\r\n);\r\nconst promise2 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 2000, `Second Promise's Value`)\r\n);\r\nconst promise3 = Promise.reject(`Third Promise's Value`);\r\n\r\nPromise.any([promise1, promise2, promise3]);\r\n\r\n// Output on the console\r\n\r\n// *Promise {&lt;fulfilled&gt;: \"Second Promise's Value\"}*\r\n</pre><p>From the above example,&nbsp;<code>promise1</code>&nbsp;will resolve after 3 seconds,&nbsp;<code>promise2</code>&nbsp;will resolve after 2 seconds, and&nbsp;<code>promise3</code>&nbsp;immediately rejects. Because&nbsp;<code>Promise.any()</code>&nbsp;is looking for the first successful promise, it returns&nbsp;<code>promise2</code>.&nbsp;<code>promise1</code>&nbsp;is a little bit late and so it's left behind.</p><p>If none of the promises in the array are resolved,&nbsp;<code style=\"color: var(--gray85);\"><strong>Promise.any()</strong></code>&nbsp;returns a rejected promise. This rejected promise contains a JavaScript array of reasons, where each reason corresponds with that of a promise from the input array.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise1 = new Promise((resolve, reject) =&gt;\r\n  setTimeout(reject, 3000, `First rejection reason`)\r\n);\r\nconst promise2 = new Promise((resolve, reject) =&gt;\r\n  setTimeout(reject, 2000, `Second rejection reason`)\r\n);\r\nconst promise3 = Promise.reject(`Third rejection reason`);\r\n\r\nPromise.any([promise1, promise2, promise3]);\r\n\r\n// Output on the console\r\n\r\n// *Promise {&lt;rejected&gt;: Aggregate Error: All Promises were rejected}*\r\n\r\nPromise.any([promise1, promise2, promise3]).catch(({ errors }) =&gt;\r\n  console.log(errors)\r\n);\r\n\r\n// Output on the console\r\n\r\n// *(3) [\"First* rejection reason*\", \"Second* rejection reason*\", \"Third* rejection reason*\"]*\r\n</pre><p>This method is useful for asynchronous operations where the fastest successful promise is all you need.&nbsp;<code>Promise.any()</code>&nbsp;and&nbsp;<code>Promise.race()</code>&nbsp;are similar, except that&nbsp;<code>Promise.any()</code>&nbsp;will return the fastest promise to complete and be resolved, while&nbsp;<code>Promise.race()</code>&nbsp;will return the fastest promise to complete and does not care if it is resolved or not.</p><p><br></p>","coverImageUrl":"https://escribir.s3.eu-north-1.amazonaws.com/1730731585593_lvpfnugwgoa","createdAt":"2024-11-04T14:46:28.066Z","heading":"What is a Promise?","reactions":[],"status":"published","tag":"JavaScript","updatedAt":"2024-11-09T05:21:12.915Z"},"1":{"__v":0,"_id":"6728abf41aec9bbaf4acfbf8","author_id":{"_id":"6719d873a7ce679095b76e01","image":"https://res.cloudinary.com/djfhotv8n/image/upload/v1729747676/Escribir_Profile_Images/ybc9vtwqaqnly2lkwjhu.jpg","username":"Sneha K"},"comments":[],"content":"<h2>Peace Starts When We Embrace Who We Are, Not Who We Should Be</h2><p><img src=\"https://cdn-images-1.readmedium.com/v2/resize:fit:800/1*3Vuj3LOBgHyrDZjmkU4Dig.png\">Image created by author using&nbsp;<a href=\"https://www.midjourney.com/app/\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: inherit;\">MidJourney</a></p><p><br></p><p><br></p><p><em>“You’re doing better than you think. Stop being so hard on yourself,”</em>&nbsp;I told my friend as he sat across from me, tears streaming down his face. His voice cracked as he repeated the words:&nbsp;<em>“I failed her. I’m not good enough. I’ll never be good enough.”&nbsp;</em>I didn’t know what else to say to him. Here was someone who had never truly accepted himself, no matter how much he accomplished.</p><p>My friend had built a multimillion-dollar business from nothing, rising out of poverty. He cared for his aging parents, sent two siblings to college, and even helped them get married — all before he turned forty. Yet, despite these incredible achievements, his response was always the same whenever I praised him:&nbsp;<em>“Not good enough. Not yet.”</em></p><p>I know this mindset well, having grown up in an entrepreneurial family where my performance was constantly measured through comparisons.<em>“Look at so-and-so’s son and how well he’s doing,”</em>&nbsp;my father would say. That sense of comparisons and expectations was relentless. The thought of meeting these standards blinded me to the 90% of things I was doing right. Instead, I became fixated on the never-ending 10% I hadn’t achieved to prove myself, and if not, I would become bitter toward myself and those I was trying to match in performance. I would develop an inflated self-confidence that I would crush all aspects of business or have zero to no confidence in certain business activities.</p><p>When I didn’t feel competitive enough, I lost opportunities and friendships when there was a better approach for collaboration and a win-win. I often didn’t know why I was competing; I just wanted to prove to my father that I was better than the other guy, and he was wrong. Initially, things might feel like you are improving and moving forward. Still, the amount of poison and negative energy you inject into yourself is much more damaging than the instant pleasure of the wins. At last, my father realized he was doing more damage than good when, during a fight, I told him, “How about you adopt one of those guys as your son, and I will find myself a better father?” It was a shock to him but a natural response from my side, being drained and always trying to follow his ideal image of the perfect son.</p><p>I have realized that one of our biggest mistakes when we don’t value ourselves is that we tie our self-worth to specific goals, metrics, or others’ constant demands and expectations. When we do that, falling short makes us feel worthless. We see ourselves as either winners or losers, with no middle ground. I had been there for a long time, and it took me countless reflections to understand that It’s tough to break free from this negative cycle unless I completely realize that my circumstances shaped my life. We all have our strengths and weaknesses and can control only so much.</p><p>My friend’s heartbreak wasn’t just about the end of his relationship; it was the overwhelming pressure he had placed on himself to be perfect in every part of his life. His girlfriend left because he was sometimes too focused on his business, not always free or mentally ready for her constant desire to hang out at social events with her friends. While he blamed himself, I knew he had always done his best given the circumstances.&nbsp;<em>“What more could you expect from yourself?”</em>&nbsp;I asked him.&nbsp;<em>“How else could you have acted within your conditions? Come on, man, at least give yourself credit for doing your best.”</em></p><p>His situation reminded me of my own struggles with self-acceptance. It took me a great deal of time to realize that self-acceptance doesn’t mean we must agree with everything we’ve done or be happy with every outcome. It simply means recognizing our efforts and staying true to ourselves. His girlfriend compared him to her friend’s boyfriends, men who might have far fewer responsibilities. Was that fair? Maybe not. He might not have been the perfect boyfriend, but he was doing his best with what life threw at him.</p><p>Through tears running down his face, he told me that night,&nbsp;<em>“I’m so tired. I don’t know what I did wrong. I gave everything I had. I don’t even know who I am anymore. Every day, I wake up trying to meet everyone’s expectations, and by the end of the day, I break into bed, exhausted. Yet, no matter what I do or how much I ‘fix’ myself, I still feel like I’m not good enough unless I meet their standards.”</em></p><p>“<em>That’s because you’re expecting happiness through changing your core to satisfy others,</em>” I told him. “<em>And no one can keep going with that for too long.</em>”</p><p>That conversation taught me a lesson I will never forget: the constant “go, go, go” mentality—the relentless craving to make everyone happy—comes at the cost of living in the present. We’re always chasing an idealized future of ourselves that never brings real happiness. We are constantly walking toward a mirage, only to find emptiness when we arrive, with a sign telling us to continue until we’re drained and broken by exhaustion.</p><p>In the past, I’ve also confused personal growth with self-acceptance, which has driven me to exhaustion in the name of “endless progress.” It’s natural to want more and to grow, but real change only happens when we acknowledge who we are despite the expectations of others or an ideal image of ourselves. Change can’t come from denying ourselves—denial leads to self-destruction. It traps us in a cycle of dwelling on past mistakes and constantly questioning our worth whenever we fall short of someone else’s standards.</p><p>At that conversation, I wished my friend could accept himself; I wish he didn’t blame himself for his past, and I wish he could live in the present and trust that despite his painful experiences, he could still grow and evolve in future relationships. Yes, his girlfriend might be wonderful, and he might be short on delivering sometimes, but maybe she wasn’t the right person for him at that point, which he realizes today.</p><p>Gladly, now he has changed his approach. Instead of trying to change himself entirely for someone, he is very open and transparent about his circumstances when he goes out on a date. It’s much happier to be honest and true to ourselves and find those who match and accept our circumstances than to change our cores to attract or maintain someone who is unwilling to see the committed part in us.</p><p><img src=\"https://cdn-images-1.readmedium.com/v2/resize:fit:800/1*-e_-zcnK0faNwbvMQonFCA.png\">Image created by author using&nbsp;<a href=\"https://www.midjourney.com/app/\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: inherit;\">MidJourney</a></p><p><br></p><p><br></p><p>Self-acceptance is difficult for many because it takes tremendous courage to be brutally honest with ourselves. It requires us to look at who we are without denial or avoidance. When we see the parts of ourselves that don’t measure up to someone else’s standards, we must also recognize the good in us — the beautiful qualities and positive force that contribute to the lives of others. That’s not easy when everyone holds you to expectations that make you feel unworthy the moment you fall short.</p><p>We all need to understand that individually we are whole beings, and collectively we paint the whole picture. You are not just a collection of good and bad parts — you are a complete person. You have strengths in certain areas, and the people you choose in life should complement you just as you complement them.</p><p>When you accept yourself and allow yourself to grow into your best form, you’ll realize that you only need to meet your natural and basic expectations, not anyone else’s. That’s when you begin to live authentically and give others the space to grow into their best selves within their abilities and circumstances.</p><p>That night, I told my friend, “<em>You don’t need all the answers right now, and that’s okay. Just understand that this is who you are, and this is your situation. Be at peace with that and move forward from there. The end of your relationship doesn’t mean you’re unlovable or incapable of giving love.</em>” I wasn’t asking him to ignore the pain or pretend nothing happened, but to acknowledge it without letting it define him. I encouraged him to see himself not as someone who failed but as someone who tried, learned, and is still standing despite it all, and today, he is finding more joy in his dating life.</p><p><br></p><p>One important lesson I’ve learned from painful experiences is to avoid comparing myself to others or being compared to anyone at any cost. I understand that life can be competitive, but comparison is not the right approach to growth. It’s the enemy of self-acceptance, breeding feelings of inadequacy. When we compare ourselves, we might create slightly better versions than others, but it comes at the expense of our authenticity. It traps us in a cycle of feeling worthless, never enough, and incapable. When we learn to see our authentic beauty, we also begin to see it in others without neglecting our self-worth. Others can inspire us, but we don’t need to become a copy of someone else in the name of improvement or to meet the demands of others.</p><p>Life teaches us that nature thrives in diversity. Each of its creations grows according to its strengths and circumstances. Denying the best in ourselves is denying the gifts life has given us. An oak tree doesn’t strive to become a smaller banana tree or a much larger mountain. It grows into its most natural and beautiful form, providing shade and strength for those who need it. That’s the essence of self-acceptance: it’s to become the best version of yourself, free from comparison. When you truly embrace that, everything else follows naturally.<strong>&nbsp;Cheers!</strong></p><p><br></p>","coverImageUrl":"https://escribir.s3.eu-north-1.amazonaws.com/1730718702669_aww8gabts9h","createdAt":"2024-11-04T11:11:48.729Z","heading":"When You Accept Yourself, Everything Else Falls Into Place","reactions":[],"status":"published","tag":"Self-Motivation","updatedAt":"2024-11-04T11:11:48.729Z"},"2":{"__v":0,"_id":"6728aaee1aec9bbaf4acfbe6","author_id":{"_id":"6719d873a7ce679095b76e01","image":"https://res.cloudinary.com/djfhotv8n/image/upload/v1729747676/Escribir_Profile_Images/ybc9vtwqaqnly2lkwjhu.jpg","username":"Sneha K"},"comments":[],"content":"<h2><br></h2><h1><br></h1><h1>How slowing down helped me move from burnout to clarity and finally discover the meaning behind my work and life</h1><h1><br></h1><p><img src=\"https://cdn-images-1.readmedium.com/v2/resize:fit:800/1*KGZwmYeby0MYf8E3pWnntA.png\">Image created by author using&nbsp;<a href=\"https://www.midjourney.com/app/\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: inherit;\">MidJourney</a></p><p><br></p><p><br></p><p><em>“I can’t stop! If I do, I’ll lose momentum, and everything I’ve built will fall apart!”</em>&nbsp;I replied in frustration.</p><p>My friend stared at me in confusion and said,&nbsp;<em>“What’s the point of it all if you’re the one falling apart?”</em></p><p><br></p><p><em><span class=\"ql-cursor\">﻿</span></em></p><p><strong>I froze. I had no answer!</strong></p><p>A few years ago, I believed that worthy accomplishment was defined by non-stop action. I thought the harder I pushed, the closer I’d get to the finish line of success. I assumed if I filled every second of my day with tasks and deadlines, I’d look and feel busy, and my goals would be achieved on autopilot.</p><p>But, in truth, I was driven by fear of falling behind. I was insecure and terrified of appearing lazy or like a procrastinator. I lived in megacities where more work was glorified, and constant busyness was a badge of discipline and focus. The problem was that the more I convinced myself I was doing the right thing, the more disconnected I became from myself. My behavior was making me less productive and even more ineffective. I spent time doing things but saw little to no noticeable return.</p><p>Looking back, I realize I left no room for reflection, no space to question whether I was doing things right. Pausing isn’t laziness; it’s wisdom. Stepping back from the noise and constant movement allows us to create space for clarity, reflection, and meaningful progress.</p><p>I often worked on projects for over 48 hours straight, with little to no sleep, forgetting and dismissing eating or even hydrating myself well. If you looked at my face, you’d see red eyes surrounded by dark circles — a zombie drained of energy. Like many of us, I, too, felt like everyone else was moving faster, and I couldn’t afford to stop. Pausing, to me, meant failure. I wish I’d known then that true success isn’t about how busy we are but about the intention behind our actions and the meaning behind our goals.</p><p>How many of us assume busyness gives us purpose? In reality, it steals our joy and clarity. We’re constantly driven by the need to prove ourselves, but in that pursuit, we forget that our well-being and happiness matter the most. When we don’t pause, breathe, and reflect, we never allow ourselves to realign with what truly matters. True accomplishment isn’t about how much we push — it’s about understanding when to take a step back and preventing ourselves from pushing too far into exhaustion</p><p>My attitude didn’t bring me the success I wanted. It led me to anxiety and depression. I became physically exhausted, mentally drained, and emotionally numb. Day after day, I watched my design proposals slip away to competitors who invested less effort but more “<strong>thoughtfulness</strong>.”</p><p>Mental health is a serious matter, and it made me stop. I was drained of energy and lacked motivation, even for the smallest tasks. My friends didn’t understand the situation and encouraged me to ignore my feelings and press on, but the harder I pushed, the more my mind and body fought back.</p><p>One night, I lost a design proposal I had spent so many days on and smashed my MacBook Pro against the wall. My ex-wife thought I was angry, but the underlying truth was I was desperate. I was hungry for success, yet my efforts yielded nothing. I listened to endless motivational videos to encourage myself, but practicality said otherwise.</p><p>The problem with the go-go-go mentality is that it fosters a scarcity mindset — do it now, or it’ll never happen. The truth is that opportunities will always exist, and we can achieve success if we slow down and think through our intentions.</p><p>My teacher in Shanghai, a wise, practical, and successful man in his 50s, captured this perfectly. One day, he told me, “<em>Maybe you are doing the right thing, but perhaps you are not doing it right. Learn to pause, move in small steps, and protect your well-being. Once you’re exhausted, it’s game over. People who aim to win know how to play longer while feeling their best.”</em></p><p>What he said was deep and true, many of us pursue the right goals, but our approach might be wrong. We put our relationships, mental health, and physical well-being at risk in the hope of achieving a future success that, to be honest, is unpredictable. We rush through everything and end up with nothing but exhaustion.</p><p>When we lose confidence, we think we’re not good enough for the job, when in reality, all we needed were moments of stillness to reflect and refill our energy. That’s why so many lose faith in themselves despite having the strength and talent to achieve their goals — if only they slowed down, contemplated, and took one small step at a time.</p><p>Burnout doesn’t happen overnight. I’ve experienced it countless times in my life. When we push ourselves beyond our limits, exhaustion becomes unavoidable. Once it takes hold, we lose clarity and purpose. What once felt meaningful becomes draining. Burnout is our spirit’s way of demanding that we need to stop.</p><p>At first, the idea of pausing and taking a step back was impossible to accept. It was completely uncomfortable because I thought I’d lose grip. It’s interesting when the brain is hooked on believing that more work equals greatness and rejects the thought of stepping away. The idea of turning off my computer, sitting on my balcony, or walking in the park without listening to a productivity book felt like proof of laziness.</p><p>What I forgot was that hardcore motivational talk is easy to say but, at times, impractical to follow. We’re human and vary in our energy levels, hormones, and emotions. There is a limit to how much we can push. I learned through experience that no matter how much guilt rushes through our minds, reminding us of what we “<strong>should</strong>” be doing, we’ll never feel like we’re doing enough — it’s human nature to want to achieve more and more.</p><p>But we forget that, at some point, our bodies will tire and push back. That’s when we have to stop, listen to our bodies, and root our sense of accomplishment in reality. Because even if we achieve materialistic success, without inner peace and moments of true relaxation, our lives will start to feel unbalanced, and the motivation and meaning we once had may begin to fade.</p><p><img src=\"https://cdn-images-1.readmedium.com/v2/resize:fit:800/1*qkct7UqT5UTJTTlpNo6YDg.png\">Image created by author using&nbsp;<a href=\"https://www.midjourney.com/app/\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: inherit;\">MidJourney</a></p><p><br></p><p><br></p><p>My first conscious step back happened when I left my phone at home and went for a walk in the park for an hour. At first, I was worried about missing messages. But then I paused and asked myself,<em>&nbsp;“What is wrong with you? You’ve been working non-stop for years, and you’ve gotten nowhere near your goals. Why do you think this one hour will make any difference?”</em></p><p>I realized I was looking busy all the time, but I wasn’t productive. I was just stuck behind my screen, eyeballs tracking the curser. When I assured myself that nothing would happen in that hour, I shifted my attention from the constant noise in my head urging me to keep overthinking about my work to the beauty of the world around me.</p><p>I noticed an elderly man who had brought a chicken to the park, letting kids play with it. Some cats in the park stared at the chicken, and a few even tried to chase it, but the man kept shooing them away. It was a joyful moment, and people laughed as they watched. The scene made me appreciate the beauty and vibrancy of the world around me, filling me with a sense of joy.</p><p>As I walked through the park, I felt the warmth of the sunlight, the breeze of fresh air, and the scent of beautiful Gardenia flowers. The tension in my muscles and the fogginess in my mind began to fade. My chest felt lighter, my breath deeper, and my thoughts clearer.</p><p>Many of us struggle with the silence that comes with stillness, but in these moments, we confront the truths buried under the weight of busyness. Learning to pause, even for small moments, helps us release what no longer serves us and discover a deeper sense of purpose. Clarity doesn’t come from doing more but from stepping back and creating space to think mindfully.</p><p>Pausing and reflecting have now become part of my daily routine. Whenever I feel myself rushing into work, I remind myself that this path only leads to burnout and exhaustion.</p><p>Sometimes, I call a friend and escape to a coffee shop or arcade for some lighthearted fun, stepping away from the constant pressure of work. These moments are important; they give me a much-needed break and allow my mind to reset.</p><p>During these moments of relaxation, I take the time to ask myself, What do I truly want? Why am I doing this? With greater clarity, I approach my work with intention, recognizing that if I’m not enjoying what I’m doing, it may not align with my passions. This realization often leads me to consider letting go of what no longer serves me and seeking out opportunities that better reflect my values. Once refreshed, I return feeling rejuvenated and ready to tackle my tasks with renewed energy.</p><p>There is a quote by John Lennon, “The time you enjoy wasting is not wasted time.” This quote resonates because pausing brings real value to our lives and is a wise use of time; it allows us to relax and act with intention, leading to more meaningful outcomes.</p><p>On the other hand, staying busy for the sake of it or rushing through projects without taking a moment to reflect on our goals and actions wastes both time and energy, often resulting in unclear aims and inefficient efforts. Pausing doesn’t mean losing momentum; it means gaining clarity and avoiding unnecessary mistakes. It allows us to approach tasks with a refreshed perspective, often leading to insights we might miss if we’re always in motion.</p><p>This change in my mindset has greatly helped me guide others toward clearer thinking as well. In my consulting business, when I see clients rushing, I urge them to slow down because, without thoughtfulness, we risk producing ineffective work that may need to be redone later. When they slow down and take the time to think about their decisions and actions, they approach tasks with more intention and ultimately appreciate the results of their careful investments — whether of time, effort, or money.</p><p><img src=\"https://cdn-images-1.readmedium.com/v2/resize:fit:800/1*IGU-4m4waL-tcb837JlbwQ.png\">Image created by author using&nbsp;<a href=\"https://www.midjourney.com/app/\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: inherit;\">MidJourney</a></p><p><br></p><p>This mindset adds “<strong>quality”</strong>&nbsp;to our lives — a concept we need to learn to embrace if we seek personal improvement. When we prioritize our mental, emotional, and physical health, everything else aligns harmoniously, allowing us to pursue our goals purposefully.</p><p>The world often demands continuous action, whether from work, relationships, or other commitments. When we fail to pause and recharge, it leads to burnout. Pausing shifts our focus from solely completing tasks to being present, allowing us to reflect on what truly matters in our lives. It allows us to consider our priorities and the relationships we value the most.</p><p>Next time you feel like you can’t stop, take a deep breath and&nbsp;<strong>ask yourself:&nbsp;</strong>What’s more important — blindly pushing forward or stepping back to find clarity? Are you moving with purpose or just keeping up with the pace? When we aim for peace, growth follows. Clarity emerges when you take a step back and trust that intention drives progress.&nbsp;<strong>Reflect on this:&nbsp;</strong>When given the choice, wouldn’t you prefer clarity over chaos? Here’s to choosing with intention.&nbsp;<strong>Cheers!</strong></p><p><br></p>","coverImageUrl":"https://escribir.s3.eu-north-1.amazonaws.com/1730718444147_v2tldzczzqq","createdAt":"2024-11-04T11:07:26.282Z","heading":"When You Pause, Your True Purpose Reveals Itself","reactions":[],"status":"published","tag":"Self-Motivation","updatedAt":"2024-11-04T11:07:26.282Z"},"3":{"__v":0,"_id":"6728a6761aec9bbaf4acfbd5","author_id":{"_id":"66ebecd0eb53f2be6b08101d","image":"https://res.cloudinary.com/djfhotv8n/image/upload/v1729616317/Escribir_Profile_Images/m4liuexkuts6xr6bdngp.jpg","username":"Jansiya jahan"},"comments":[],"content":"<h3><strong>Visual representations</strong></h3><p>I think it’s always good to start with some visualization.</p><p>Here are the most common pictures of this concept.</p><p><img src=\"https://cdn-media-1.freecodecamp.org/images/oVVbTLR5gXHgP8Ehlz1qzRm5LLjX9kv2Zri6\" alt=\"Image\" height=\"567\" width=\"772\"></p><p><img src=\"https://cdn-media-1.freecodecamp.org/images/YsN6twE3-4Q4OYpgxoModmx29I8zthQ3f0OR\" alt=\"Image\" height=\"400\" width=\"600\">_Source and credit: [https://www.codingblocks.net/podcast/clean-architecture-make-your-architecture-scream/](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html\" rel=\"noopener\" target=\"_blank\" title=\"\"&gt;https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html .&lt;a href=\"https://www.codingblocks.net/podcast/clean-architecture-make-your-architecture-scream/\" rel=\"noopener\" target=\"<em style=\"color: var(--gray85);\">blank\" title=\")</em></p><p><img src=\"https://cdn-media-1.freecodecamp.org/images/lbexLhWvRfpexSV0lSIWczkHd5KdszeDy9a3\" alt=\"Image\" height=\"400\" width=\"600\"></p><p><img src=\"https://cdn-media-1.freecodecamp.org/images/YIABVRTHRz58ZiT6W-emBkfNIQUHBelp8t6U\" alt=\"Image\" height=\"400\" width=\"600\">_Source and credit: Mattia Battiston, under CC BY 4.0, [https://github.com/mattia-battiston/clean-architecture-example](https://github.com/mattia-battiston/clean-architecture-example\" rel=\"noopener\" target=\"<em style=\"color: var(--gray85);\">blank\" title=\")</em></p><p><img src=\"https://cdn-media-1.freecodecamp.org/images/TmSQbZOg5bxn0cRXxIrRUd2zhqeDAXTe8ni5\" alt=\"Image\" height=\"400\" width=\"600\">_Source and credit: [https://marconijr.com/posts/clean-architecture-practice/](https://marconijr.com/posts/clean-architecture-practice/\" rel=\"noopener\" target=\"<em style=\"color: var(--gray85);\">blank\" title=\")</em></p><h3><strong>The concept — presented in bullet points</strong></h3><p>Extended from Source and credit:&nbsp;<a href=\"https://github.com/mattia-battiston/clean-architecture-example\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: var(--gray90); background-color: transparent;\">Mattia Battiston, under CC BY 4.0</a></p><h4><strong>The value it can provide</strong></h4><ul><li>An effective testing strategy that follows the testing pyramid</li><li>Frameworks are isolated in individual modules. When (not if) we change our mind, we only have to make a change in one place. The app has use cases rather than being tied to a CRUD system</li><li>Screaming architecture a.k.a. it screams its intended usage. When you look at the package structure, you get a feel for what the application does rather than seeing technical details</li><li>All business logic is in a use case, so it’s easy to find and not duplicated anywhere else</li><li>Hard to do the wrong thing because modules enforce compilation dependencies. If you try to use something that you’re not meant to, the app doesn’t compile</li><li>It is always ready to deploy by leaving the wiring up of the object for last. Or by using feature flags, so we get all the benefits of continuous integration</li><li>Multiple works on stories so that different pairs can easily work on the same story at the same time to complete it quicker</li><li>Good monolith with clear use cases that you can split in microservices later on, once you’ve learned more about them</li></ul><h4><strong>Entities</strong></h4><ul><li>Represent your domain object</li><li>Apply only logic that is applicable in general to the whole entity (e.g., validating the format of a hostname)</li><li>Plain objects: no frameworks, no annotations</li></ul><h4><strong>Use Cases</strong></h4><ul><li>Represent your business actions: it’s what you can do with the application. Expect one use case for each business action</li><li>Pure business logic, plain code (except maybe some utils libraries)</li><li>The use case doesn’t know who triggered it and how the results are going to be presented (for example, could be on a web page, or — returned as JSON, or simply logged, and so on.)</li><li>Throws business exceptions</li></ul><h4><strong>Interfaces / Adapters</strong></h4><ul><li>Retrieve and store data from and to a number of sources (database, network devices, file system, 3rd parties, and so on.)</li><li>Define interfaces for the data that they need in order to apply some logic. One or more data providers will implement the interface, but the use case doesn’t know where the data is coming from</li><li>Implement the interfaces defined by the use case</li><li>There are ways to interact with the application, and typically involve a delivery mechanism (for example, REST APIs, scheduled jobs, GUI, other systems)</li><li>Trigger a use case and convert the result to the appropriate format for the delivery mechanism</li><li>the controller for a MVC</li></ul><h4><strong>External Interfaces</strong></h4><ul><li>Use whatever framework is most appropriate (they are going to be isolated here anyway)</li></ul><h3><strong>Code example</strong></h3><p>See the structure on&nbsp;<a href=\"https://github.com/Createdd/web-miner/tree/master/webminer\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: var(--gray90); background-color: transparent;\">GitHub</a>.</p><p>First of all, it is important to understand that clean architecture is a bundle of organising principles. So therefore everything is open to personal adjustments as long as core ideas are kept intact. The linked repository is a fork of the original project that brought this architecture design idea to me. Feel free to check out the original project as well, as it reflects further improvements.</p><p>The webminer folder is structured into the basic layers:</p><ol><li>entities</li><li>use_cases</li><li>interfaces_adapters</li><li>external_interfaces</li></ol><p><img src=\"https://cdn-media-1.freecodecamp.org/images/FSvBm5GdWA0uMo6NJhyOoF2hgJt8s1Bv3n1v\" alt=\"Image\" height=\"400\" width=\"600\"><em style=\"color: var(--gray85);\">Structure of the webminer folder</em></p><p>It shall reflect the very basic approach for the design pattern.</p><ul><li>Starting from&nbsp;<code>entities</code>, you can see that the core model of this project is the&nbsp;<code>arxiv_document</code></li><li>The next folder,&nbsp;<code>use_cases</code>&nbsp;shows our use case, namely to request the arxiv page</li><li>After that, we go through the&nbsp;<code>interface_adapters</code>&nbsp;folder that provides adapters for process requests in a REST application or for serializing</li><li>The final and last layer is&nbsp;<code>external_interfaces</code>. This is where we use the flask server to implement the REST functionality</li></ul><p>All of those layers are dependent on the core layers but not the other way around.</p><p><strong style=\"color: var(--gray85);\">One important note: This is not 100% correctly implemented in the repository.</strong></p><p>Why? Because the use cases are actually different. In reality the main use case is to provide the structured data. Another use case is to get the data from the arxiv page.</p><p>Did you spot this error in the architecture? If yes, congratulations! Not only did you bring enough curiosity to this article but you likely understand the principles well enough to build your own case and apply the concepts in reality!</p><p>Do you agree? If not, why? Thanks for reading my article! Feel free to leave any feedback!</p>","coverImageUrl":"https://escribir.s3.eu-north-1.amazonaws.com/1730717299890_5yzadkrd3l5","createdAt":"2024-11-04T10:48:22.122Z","heading":"A quick introduction to clean architecture","reactions":[],"status":"published","tag":"JavaScript","updatedAt":"2024-11-04T10:48:22.122Z"},"4":{"__v":0,"_id":"6728a6291aec9bbaf4acfbcd","author_id":{"_id":"66ebecd0eb53f2be6b08101d","image":"https://res.cloudinary.com/djfhotv8n/image/upload/v1729616317/Escribir_Profile_Images/m4liuexkuts6xr6bdngp.jpg","username":"Jansiya jahan"},"comments":[],"content":"<p><span style=\"color: rgb(36, 36, 36);\">TypeScript is an open-source programming language developed by Microsoft. It is a statically typed superset of JavaScript, which means that any valid JavaScript code is also valid TypeScript code. However, TypeScript adds optional static typing and other features to help developers write more scalable and maintainable code. TypeScript and JavaScript are like brothers. As you know JavaScript was made in year of 1995 only in ten days it show how hurriedly in urgency they made this language so it have so many errors but now after so many upgrades its good to go. but now we have TypeScript which is more tackle-able as compared to JavaScript so in TypeScript</span></p><p><br></p><ul><li><span class=\"ql-cursor\">﻿</span>TypeScript&nbsp;<a href=\"https://www.youtube.com/redirect?event=video_description&amp;redir_token=QUFFLUhqbFFvT1ZkSnVYUllvZ0JPZTg5b2FmbkRBN3lOd3xBQ3Jtc0tubXkxQWo1SjNoelFjSTk4dnZvMXlkTEVNamp3WDNPYTlURzBfSXZXS2RtMmJHRmp0S2dLaHNjS25nVUFuNVlWdFdMWk1EUU1DQXBRVldTb3JWTk9Uc1lRcElkRmxpckZHVFgwYnFZWHducDdwNEdlMA&amp;q=https%3A%2F%2Fwww.typescriptlang.org%2Fdownload&amp;v=f3xeJOvqUPQ\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: inherit;\">https://www.typescriptlang.org/download</a></li></ul><p><br></p><p><span style=\"color: rgb(36, 36, 36);\"><img src=\"https://miro.medium.com/v2/resize:fit:708/1*-GCUmL0FbFSpT2SLa74P4Q.png\" alt=\"https://www.typescriptlang.org/download\" height=\"215\" width=\"566\"></span></p><p><span style=\"color: rgb(36, 36, 36);\">So here’s a breakdown of some key concepts in TypeScript:</span></p><ul><li>Static Typing: TypeScript allows you to specify types for variables, function parameters, return types, and more. This helps catch type-related errors during development and provides better tooling support for code editors.</li><li>Type Inference: TypeScript’s type inference system can often automatically infer types based on how you’ve written your code. This means you don’t always have to explicitly specify types, though you can if you want to be more explicit.</li><li>Interfaces and Types: TypeScript allows you to define custom types using interfaces and types. These can describe the shape of objects, including the types of their properties and methods.</li><li>Classes and Inheritance: TypeScript supports object-oriented programming features like classes, inheritance, and access modifiers (public, private, and protected).</li><li>Enums: TypeScript provides support for enums, which allow you to define a set of named constants. Enums are useful when you have a fixed set of values that a variable can take.</li><li>Generics: TypeScript supports generics, which allow you to write reusable code that can work with a variety of data types while still maintaining type safety.</li><li>Modules: TypeScript supports modular programming through the use of modules. You can import and export functionality between different files, which helps organize code and manage dependencies.</li></ul><p>Overall, TypeScript aims to make it easier to build large-scale JavaScript applications by adding features that help catch errors early, improve code maintainability, and provide better tooling support. It compiles down to plain JavaScript, through node.js it works as a compiler in between JS &amp; TS so it easily run on any JavaScript runtime, making it a versatile choice for web development.<span style=\"color: rgb(36, 36, 36);\">&nbsp;</span></p>","coverImageUrl":"https://escribir.s3.eu-north-1.amazonaws.com/1730717223118_5njbdoap6ps","createdAt":"2024-11-04T10:47:05.763Z","heading":"Introduction To TypeScript","reactions":[],"status":"published","tag":"TypeScript","updatedAt":"2024-11-04T10:47:05.763Z"},"5":{"__v":0,"_id":"67288d201aec9bbaf4acfb11","author_id":{"_id":"66ebecd0eb53f2be6b08101d","image":"https://res.cloudinary.com/djfhotv8n/image/upload/v1729616317/Escribir_Profile_Images/m4liuexkuts6xr6bdngp.jpg","username":"Jansiya jahan"},"comments":[],"content":"<p><img src=\"https://miro.medium.com/v2/resize:fit:875/0*kCfge4a9Xm0zyqcP\" height=\"394\" width=\"700\"></p><p><strong>First lets Define what WebRTC is</strong></p><p>WebRTC is a set of JavaScript API’s that allow us to establish a peer to peer connection between two browsers to exchange data such as audio and video, allowing us to create applications with audio and video calling features.</p><p>What makes WebRTC special is that once a connection is established; data can be transmitted directly between browsers in real time without touching the server.&nbsp;By bypassing the server we reduce latency since the data doesn’t have to go to the server first, this makes webRTC great for exchanging audio and video.</p><p>Full video tutorial: “<a href=\"https://youtu.be/8I2axE6j204\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: inherit;\">How Does WebRTC Work? | Crash Course</a>”</p><p><strong>WebRTC Vs WebSockets</strong></p><p>Before we talk about how all this works, let’s look at the comparison between WebRTC and WebSockets since I know a lot of you are thinking “this sounds a lot like WebSockets, so why do we need WebRTC?” or vice versa.</p><p><img src=\"https://miro.medium.com/v2/resize:fit:875/0*Own87NQd76MSw2hc\" height=\"308\" width=\"700\"></p><p>With websockets we can also establish a connection between peers to exchange data in real time, but this connection is between the client and server. So if I send a message to a peer, the message first goes to the server, then the server sends that message to the other peer. This exchange typically happens really fast so even though there is some latency, you probably wouldn’t even notice it if you’re sending something like a chat message or some kind of notification.</p><p>Now let’s say we wanted to exchange some audio or video using websockets, after all this is possible.</p><p>The problem here is that even the slightest latency when it comes to audio and video can be very noticeable and causes a lot of issues. So by the time your video data hits the server and back to your peer, you’re gonna see a significant delay.</p><p>This is where webRTC makes sense. By establishing a connection and exchanging data between two browsers we eliminate any delay that the server may add. WebRTC also uses User Datagram Protocol, or UDP, which is great for transmitting data really fast but more on that in a moment.</p><p><strong>So if webRTC is so fast, why use websockets at all?</strong></p><p>There are certain limitations with webRTC so typically using webRTC with websockets is more of a common practice.</p><p>First, webRTC uses UDP, and UDP is not a reliable protocol for transferring important data. UDP is good at sending data really fast but it doesn’t check whether or not the data is being received. So UDP is great for video because the data gets there fast and if we lose a few frames it’s not a big deal; but if this were a file we needed to send over and we lose a few bytes of data the entire file can be corrupted.</p><p>WebRTC also has no built-in signaling so it cant be used on its own to establish a peer to peer connection. WebRTC takes care of everything for us once the connection is established but leaves it up to us on how to transmit the initial data in order to connect two peers.</p><p><strong>So how does all of this work?</strong></p><p><img src=\"https://miro.medium.com/v2/resize:fit:875/0*8CIZHw7jhUcAqM96\" height=\"394\" width=\"700\"></p><p>From a high level perspective, to establish a connection, peer 1 will send some kind of message to peer 2 saying “hey, I want to connect to you, here’s some information about me and how you can connect to me, do you accept my offer?”</p><p>How this message is sent is irrelevant. This could be an email, a tweet OR you can signal it over to peer 2, it doesn’t matter, that parts up to you.</p><p>When peer 2 gets this information from peer 1, they have the opportunity to accept the connection. If peer 2 accepts, they will gather some information about their network and how to connect to it, and then send this information back to peer 1.</p><p>Once both peers have eachothers information, they are now connected and can now begin exchanging audio and video data or whatever else they want to send directly between their browsers without needing the server anymore.</p><p><strong>So what exactly is sent between the two clients and how is it sent?</strong></p><p>First off, how the information is sent is usually through a process called signaling. Since the two peers don’t know about each other we would typically have a way to bring them into a channel together using something like WebSockets or any third party signaling services.</p><p>Once we bring them into the same channel or room, they can now signal over their connection details. Those connection details come in the form of a session description protocol (SDP) and ICE candidates.</p><blockquote><strong><em>SDP&nbsp;</em></strong><em>— A Session Description Protocol (SDP), is an object containing information about the session connection such as the codec, address, media type, audio and video and so on. Both peers will exchange SDP’s so they can understand how to connect to each other. One in the form of an</em><strong><em>&nbsp;</em></strong><em>SDP Offer and another as an SDP Answer</em><strong><em>.</em></strong></blockquote><blockquote><strong><em>Ice Candidates</em></strong><em>&nbsp;— An ICE candidate is a public IP address and port that could potentially be an address that receives data. Each user will typically have multiple Ice candidates that are gathered by making a series of requests to a STUN server.</em></blockquote><p>Exchanging Session Description Protocols and ICE candidates</p><p><img src=\"https://miro.medium.com/v2/resize:fit:875/0*cVujHaI_uJlRKGbZ\" height=\"394\" width=\"700\"></p><p><strong>So here is the order in which things will play out.</strong></p><p>First the two peers will exchange SDP’s using some sort of signaling method. Once the two SDP’s are exchanged the peers are now connected, but still CANNOT transmit data yet.</p><p>In order to exchange data between two peers we still need to transmit the data.The problem here is that nowadays most devices sit behind firewalls and NAT devices, so to coordinate the discovery of our public IP addresses we use a method called ICE, which stands for Interactive Connectivity Establishment.</p><p>So in the background once SDP offers are exchanged each peer will then make a series of requests to a STUN server which will generate a list of ICE candidates to use. STUN servers are cheap and easy to maintain and because of that there are tons of free services you can use so you won’t have to worry about setting one up.</p><p>Once peer 1 gets these ICE candidates back from the STUN they will send them over to peer 2 and will let the network determine the best candidate to use. Peer 2 will do the same by requesting their ICE candidates and then sending them to peer 1.</p><p>When these candidates are exchanged and an optimal path is discovered data can begin to flow between the two peers.</p><p><strong>Trickling ICE Candidates</strong></p><p>There’s one problem with the process of retrieving ice candidates and that is that it can take time. So for this we commonly use a method called “Trickle ICE” which means that as we receive each ICE candidate from the STUN server we will simply send them over one by one, so they will “trickle in”.</p><p><strong>Seeing it in action</strong></p><p>I put together a live demo so you can see how the SDP transfer process works without a signaling server. With this live demo you’ll open two tabs side by side and create, then transfer and SDP offer and answer between two peers. We won’t have to deal with Trickling on ICE candidates since they will be added to the SDP offer on creation.</p>","coverImageUrl":"https://escribir.s3.eu-north-1.amazonaws.com/1730710814257_c13u3ik81i8","createdAt":"2024-11-04T09:00:16.666Z","heading":"How does WebRTC work?","reactions":[],"status":"published","tag":"WebSocket","updatedAt":"2024-11-04T09:00:16.666Z"},"level":"info","message":"Blogs fetched:","timestamp":"2024-11-20T10:37:18.466Z"}
{"level":"info","message":"Fetching all blogs","timestamp":"2024-11-20T10:37:18.498Z"}
{"0":{"__v":0,"_id":"6728de448569245cc7ef2a74","author_id":{"_id":"6703c069d7012c3ddb50b644","image":"https://res.cloudinary.com/djfhotv8n/image/upload/v1728299835/Escribir_Profile_Images/ocyxece9pbagrcwn55zl.jpg","username":"Kunujuzz"},"comments":[],"content":"<p><img src=\"https://www.freecodecamp.org/news/content/images/2023/06/A9vQ.gif\" alt=\"An animated Pinky Promise between two people\" height=\"225\" width=\"400\"><em style=\"color: var(--gray85);\">Image Credit:&nbsp;</em><a href=\"https://gifer.com/en/Pxwc\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: var(--gray90); background-color: transparent;\"><em>https://gifer.com</em></a></p><p>A promise is an assurance or guarantee that something will happen in the future. A person can promise another person a specific outcome or result. Promises are not limited to individuals, governments and organizations can also make promises. You have probably made a promise before.</p><p>With this assurance (promise) comes two possible outcomes–either fulfillment or failure. A promise is tied to an outcome that will show it is fulfilled. If that outcome does not happen, then the promise failed. A promise at the end must have one of these results.</p><p>In JavaScript, a Promise is an&nbsp;<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_objects\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: var(--gray90); background-color: transparent;\">object</a>&nbsp;that will produce a single value some time in the future. If the promise is successful, it will produce a resolved value, but if something goes wrong then it will produce a reason why the promise failed. The possible outcomes here are similar to that of promises in real life.</p><p>JavaScript promises can be in one of three possible states. These states indicate the progress of the promise. They are:</p><ul><li><em style=\"color: var(--gray85);\">pending</em>: This is the default state of a defined promise</li><li><em style=\"color: var(--gray85);\">fulfilled</em>: This is the state of a successful promise</li><li><em style=\"color: var(--gray85);\">rejected</em>: This is the state of a failed promise</li></ul><p>A promise goes from&nbsp;<em style=\"color: var(--gray85);\">pending</em>&nbsp;to&nbsp;<em style=\"color: var(--gray85);\">fulfilled</em>, or from&nbsp;<em style=\"color: var(--gray85);\">pending</em>&nbsp;to&nbsp;<em style=\"color: var(--gray85);\">rejected—</em>‘fulfilled’ and ‘rejected’ indicate the end of a promise.</p><p>From now on, this article will refer to a 'promise' as the JavaScript object.</p><h2><strong>How to Create a Promise in JavaScript</strong></h2><p>To create a promise, you need to create an instance object using the&nbsp;<code>Promise</code>&nbsp;constructor function. The&nbsp;<code>Promise</code>&nbsp;constructor function takes in one parameter. That parameter is a function that defines when to resolve the new promise, and optionally when to reject it.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise = new Promise((resolve, reject) =&gt; {\r\n  // Condition to resolve or reject the promise\r\n});\r\n</pre><p>For example, assume you want a promise to resolve after a timeout of two seconds. You can achieve this by writing it into the parameter of the constructor function.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise = new Promise((resolve, reject) =&gt; {\r\n  setTimeout(() =&gt; resolve(\"Done!\"), 2000);\r\n});\r\n</pre><p>In promises,&nbsp;<code>resolve</code>&nbsp;is a function with an optional parameter representing the resolved value. Also,&nbsp;<code>reject</code>&nbsp;is a function with an optional parameter representing the reason why the promise failed. In the example above, the resolved value of the promise is the string&nbsp;<code>'Done!'</code>.</p><p>Here is yet another example showing how you can resolve or reject a promise based on the conditions you set. In this example, the outcome of the promise is based on a random number the program generates.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise = new Promise((resolve, reject) =&gt; {\r\n  const num = Math.random();\r\n  if (num &gt;= 0.5) {\r\n    resolve(\"Promise is fulfilled!\");\r\n  } else {\r\n    reject(\"Promise failed!\");\r\n  }\r\n});\r\n</pre><p>From these examples, you can see that you have control over when to resolve or reject your promise and can tie it to a certain condition. With that, you have learned how to create a promise in JavaScript.</p><h2><strong>How to Attach a Callback to a Promise</strong></h2><p>To create a callback for a promise, you need to use the&nbsp;<code>.then()</code>&nbsp;method. This method takes in two callback functions. The first function runs if the promise is resolved, while the second function runs if the promise is rejected.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise = new Promise((resolve, reject) =&gt; {\r\n  const num = Math.random();\r\n  if (num &gt;= 0.5) {\r\n    resolve(\"Promise is fulfilled!\");\r\n  } else {\r\n    reject(\"Promise failed!\");\r\n  }\r\n});\r\n\r\nfunction handleResolve(value) {\r\n  console.log(value);\r\n}\r\n\r\nfunction handleReject(reason) {\r\n  console.error(reason);\r\n}\r\n\r\npromise.then(handleResolve, handleReject);\r\n// Promise is fulfilled!\r\n// or\r\n// Promise failed!\r\n</pre><p>That is the way to handle the possible outcomes of your promise. Any unhandled errors in your promise will keep them in a rejected state at the end but handled errors makes the operation return a fulfilled promise.</p><p>It is possible to create an immediately resolved promise, and then attach a callback with the&nbsp;<code>.then()</code>&nbsp;method. You can also create an immediately rejected promise in the same way too.</p><pre class=\"ql-syntax\" spellcheck=\"false\">Promise.resolve(\"Successful\").then((result) =&gt; console.log(result));\r\n// Successful\r\n\r\nPromise.reject(\"Not successful\").then((result) =&gt; console.log(result));\r\n// Error: Uncaught (in promise)\r\n</pre><p>The error in the rejected promise is because you need to define a separate callback to handle a rejected promise.</p><pre class=\"ql-syntax\" spellcheck=\"false\">Promise.reject(\"Not successful\").then(\r\n  () =&gt; {\r\n    /*Empty Callback if Promise is fulfilled*/\r\n  },\r\n  (reason) =&gt; console.error(reason)\r\n);\r\n// Not Successful\r\n</pre><p>Now you have properly handled a rejected outcome.</p><p>Promises make it incredibly easy to chain asynchronous instructions. When you handle a promise with the&nbsp;<code style=\"color: var(--gray85);\"><strong>.then()</strong></code>&nbsp;method, the operation always returns another promise. By employing this approach, you can eliminate the previously mentioned 'Callback Pyramid of Doom'.</p><p>Consider the code that previously caused the pyramid structure:</p><pre class=\"ql-syntax\" spellcheck=\"false\">fetchResource(\r\n  url,\r\n  function (result) {\r\n    // Do something with the result\r\n    fetchResource(\r\n      newUrl,\r\n      function (result) {\r\n        // Do something with the new result\r\n        fetchResource(\r\n          anotherUrl,\r\n          function (result) {\r\n            // Do something with the new result\r\n          },\r\n          failureCallback\r\n        );\r\n      },\r\n      failureCallback\r\n    );\r\n  },\r\n  failureCallback\r\n);\r\n</pre><p>However, because&nbsp;<code>.then()</code>&nbsp;returns another promise, this is how to write the same instructions above with promises:</p><pre class=\"ql-syntax\" spellcheck=\"false\">fetchResource(url)\r\n  .then(handleResult, failureCallback)\r\n  .then(handleNewResult, failureCallback)\r\n  .then(handleAnotherResult, failureCallback);\r\n</pre><p>As you can see, calling promises does not require a nested syntax. You can even eliminate the repeated&nbsp;<code>failureCallback</code>&nbsp;to make the code a lot neater, which is something the upcoming section of the article will explore.</p><h2><strong>How to Handle Errors in a Promise</strong></h2><p>To handle errors in Promises, use the&nbsp;<code>.catch()</code>&nbsp;method. If anything goes wrong with any of your promises, this method can catch the reason for that error.</p><pre class=\"ql-syntax\" spellcheck=\"false\">Promise.reject(new Error()).catch((reason) =&gt; console.error(reason));\r\n// Error\r\n</pre><p>This time in our example, the error output is no longer ‘uncaught’ because of&nbsp;<code>.catch()</code>.</p><p>You can also use the&nbsp;<code>.catch()</code>&nbsp;method in a chain of promises. It catches the first error it encounters in the chain.</p><p>For instance, refactoring the chain of promises following the&nbsp;<code>fetchResource()</code>&nbsp;function from the example of the previous section. This how you can stop error callback repetition in your code.</p><pre class=\"ql-syntax\" spellcheck=\"false\">fetchResource(url)\r\n  .then(handleResult)\r\n  .then(handleNewResult)\r\n  .then(handleAnotherResult)\r\n  .catch(failureCallback);\r\n</pre><p>You can also use&nbsp;<code>.catch()</code>&nbsp;to check for errors in a group of promises before proceeding with further asynchronous operations.</p><pre class=\"ql-syntax\" spellcheck=\"false\">fetchResource(url)\r\n  .then(handleResult)\r\n  .then(handleNewResult)\r\n  .catch(failureCallback)\r\n  // Check for Errors in the above group of promises before proceeding\r\n  .then(handleAnotherResult);\r\n</pre><p>The&nbsp;<code style=\"color: var(--gray85);\"><strong>.catch()</strong></code>&nbsp;method addresses any errors in a promise without requiring the nesting of error callback functions.</p><p>To chain an asynchronous operation to a promise regardless of if the promise is resolved or not, use the&nbsp;<code>.finally()</code>&nbsp;method. The&nbsp;<code>.then()</code>&nbsp;method is how you handle the results of a promise writing individual conditions for both resolved and rejected.&nbsp;<code>.catch()</code>&nbsp;runs only when there is an error. But sometimes you might want an operation to run no matter what happens to earlier promises.</p><p>Using&nbsp;<code>finally()</code>&nbsp;helps prevent possible code repetition in&nbsp;<code>.then()</code>&nbsp;and&nbsp;<code>.catch()</code>. It is for operations you must run whether there is an error or not.</p><pre class=\"ql-syntax\" spellcheck=\"false\">fetchResource(url)\r\n  .then(handleResult)\r\n  .then(handleNewResult)\r\n  .finally(onFinallyHandle);\r\n</pre><p>The&nbsp;<code>finally()</code>&nbsp;method has a few use cases in real-world applications. It is important if you want to perform cleanup operations for activities the promise initiated. Another use case—on Front-End Web Applications—is making user interface updates like stopping a loading spinner.</p><h2><strong>How to Handle Many Promises at Once</strong></h2><p>It is possible to run more than one promise at a time. All the examples you have seen so far are for promises that run one after the other.</p><p>In the previous examples, promises run similarly to synchronous code in the sense that they wait for the previous one to be resolved or rejected. But you could have multiple promises that run in parallel.</p><p>Here are the available methods that can help us achieve this:</p><ul><li><code>Promise.all()</code></li><li><code>Promise.race()</code></li><li><code>Promise.any()</code></li><li><code>Promise.allSettled()</code></li></ul><p>In this section of the article, we'll review these methods.</p><h3><strong>The&nbsp;</strong><code><strong>Promise.all()</strong></code><strong>&nbsp;method</strong></h3><p><code style=\"color: var(--gray85);\"><strong>Promise.all()</strong></code>&nbsp;accepts an array of promises as an argument but returns a single promise as the output. The single promise it returns resolves with an array of values if all the promises in the input array are fulfilled. The array&nbsp;<code>Promise.all()</code>&nbsp;resolves with will contain the resolve values of individual promises in the input array.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise1 = Promise.resolve(`First Promise's Value`);\r\nconst promise2 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 3000, `Second Promise's Value`)\r\n);\r\nconst promise3 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 2000, `Third Promise's Value`)\r\n);\r\n\r\nPromise.all([promise1, promise2, promise3]);\r\n\r\n// Output on the console\r\n\r\n// *Promise {&lt;fulfilled&gt;: Array(3)}*\r\n\r\nPromise.all([promise1, promise2, promise3]).then((values) =&gt; {\r\n  values.forEach((value) =&gt; console.log(value));\r\n});\r\n\r\n// Output on the console\r\n\r\n// First Promise's Value\r\n// Second Promise's Value\r\n// Third Promise's Value\r\n</pre><p>If at least one promise in the input array does not resolve,&nbsp;<code>Promise.all()</code>&nbsp;will return a rejected promise with a reason. The reason for the rejection will be the same as that of the first rejected promise in the input array.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise1 = Promise.resolve(`First Promise's Value`);\r\nconst promise2 = new Promise((resolve, reject) =&gt;\r\n  setTimeout(reject, 2000, `First reason for rejection`)\r\n);\r\nconst promise3 = new Promise((resolve, reject) =&gt;\r\n  setTimeout(reject, 3000, `Second reason for rejection`)\r\n);\r\n\r\nPromise.all([promise1, promise2, promise3]);\r\n\r\n// Output on the console\r\n\r\n// *Promise {&lt;rejected&gt;: \"First reason for rejection\"}*\r\n</pre><p><code>Promise.all()</code>&nbsp;will run all the input promises before it returns a value. But it does not run the promises one after the other–instead it runs them at the same time.</p><p>This is why the total time it would take&nbsp;<code>Promise.all()</code>&nbsp;to return a value is roughly the time it would take the longest promise in the array to finish.</p><p><img src=\"https://www.freecodecamp.org/news/content/images/2023/06/quickpoll.png\" alt=\"Illustration showing when Promise.all() will produce a value\" height=\"753\" width=\"960\"></p><p>Despite that, it has to finish running&nbsp;<em style=\"color: var(--gray85);\">all</em>&nbsp;the promises before it returns anything.</p><h3><strong>The&nbsp;</strong><code><strong>Promise.race()</strong></code><strong>&nbsp;method</strong></h3><p><code>Promise.race()</code>&nbsp;accepts an array of promises as an argument and returns a single promise as an output. The single promise it returns is the fastest promise to finish running—resolved or not. This means&nbsp;<code>Promise.race()</code>&nbsp;will return the promise with the shortest execution time in an array of promises.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise1 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 3000, `First Promise's Value`)\r\n);\r\nconst promise2 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 2000, `Second Promise's Value`)\r\n);\r\nconst promise3 = Promise.resolve(`Third Promise's Value`);\r\n\r\nPromise.race([promise1, promise2, promise3]);\r\n\r\n// Output on the console\r\n\r\n// *Promise {&lt;fulfilled&gt;: \"Third Promise's Value\"}*\r\n</pre><p>In the example above, because&nbsp;<code>promise3</code>&nbsp;is a promise that resolves on being created,&nbsp;<code>Promise.race()</code>&nbsp;returns it as the fastest. Just like other&nbsp;<code>Promise</code>&nbsp;methods the article discusses in this section, it runs the promises in parallel and not one after the other.</p><p>If the promise with the shortest execution time happens to be rejected with a reason,&nbsp;<code>Promise.race()</code>&nbsp;returns a rejected promise and the reason why the fastest promise was rejected.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise1 = Promise.reject(`Reason for rejection`);\r\nconst promise2 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 3000, `First resolved Promise`)\r\n);\r\nconst promise3 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 2000, `Second resolved Promise`)\r\n);\r\n\r\nPromise.race([promise1, promise2, promise3]);\r\n\r\n// Output on the console\r\n\r\n// *Promise {&lt;rejected&gt;: \"Reason for rejection\"}*\r\n</pre><p><img src=\"https://www.freecodecamp.org/news/content/images/2023/06/quickpoll--3-.png\" alt=\"Illustration showing when Promise.race() will produce a value\" height=\"772\" width=\"1040\"></p><p><code>Promise.race()</code>&nbsp;is useful for running a list of asynchronous operations but only needing the result of the fastest executed operation.</p><h3><strong>The&nbsp;</strong><code><strong>Promise.any()</strong></code><strong>&nbsp;method</strong></h3><p><code>Promise.any()</code>&nbsp;accepts an array of Promises as an argument but returns a single Promise as the output. The single promise it returns is the first resolved promise in the input array. This method waits for&nbsp;<em style=\"color: var(--gray85);\">any</em>&nbsp;promise in the array to be resolved and would immediately return it as the output.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise1 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 3000, `First Promise's Value`)\r\n);\r\nconst promise2 = new Promise((resolve) =&gt;\r\n  setTimeout(resolve, 2000, `Second Promise's Value`)\r\n);\r\nconst promise3 = Promise.reject(`Third Promise's Value`);\r\n\r\nPromise.any([promise1, promise2, promise3]);\r\n\r\n// Output on the console\r\n\r\n// *Promise {&lt;fulfilled&gt;: \"Second Promise's Value\"}*\r\n</pre><p>From the above example,&nbsp;<code>promise1</code>&nbsp;will resolve after 3 seconds,&nbsp;<code>promise2</code>&nbsp;will resolve after 2 seconds, and&nbsp;<code>promise3</code>&nbsp;immediately rejects. Because&nbsp;<code>Promise.any()</code>&nbsp;is looking for the first successful promise, it returns&nbsp;<code>promise2</code>.&nbsp;<code>promise1</code>&nbsp;is a little bit late and so it's left behind.</p><p>If none of the promises in the array are resolved,&nbsp;<code style=\"color: var(--gray85);\"><strong>Promise.any()</strong></code>&nbsp;returns a rejected promise. This rejected promise contains a JavaScript array of reasons, where each reason corresponds with that of a promise from the input array.</p><pre class=\"ql-syntax\" spellcheck=\"false\">const promise1 = new Promise((resolve, reject) =&gt;\r\n  setTimeout(reject, 3000, `First rejection reason`)\r\n);\r\nconst promise2 = new Promise((resolve, reject) =&gt;\r\n  setTimeout(reject, 2000, `Second rejection reason`)\r\n);\r\nconst promise3 = Promise.reject(`Third rejection reason`);\r\n\r\nPromise.any([promise1, promise2, promise3]);\r\n\r\n// Output on the console\r\n\r\n// *Promise {&lt;rejected&gt;: Aggregate Error: All Promises were rejected}*\r\n\r\nPromise.any([promise1, promise2, promise3]).catch(({ errors }) =&gt;\r\n  console.log(errors)\r\n);\r\n\r\n// Output on the console\r\n\r\n// *(3) [\"First* rejection reason*\", \"Second* rejection reason*\", \"Third* rejection reason*\"]*\r\n</pre><p>This method is useful for asynchronous operations where the fastest successful promise is all you need.&nbsp;<code>Promise.any()</code>&nbsp;and&nbsp;<code>Promise.race()</code>&nbsp;are similar, except that&nbsp;<code>Promise.any()</code>&nbsp;will return the fastest promise to complete and be resolved, while&nbsp;<code>Promise.race()</code>&nbsp;will return the fastest promise to complete and does not care if it is resolved or not.</p><p><br></p>","coverImageUrl":"https://escribir.s3.eu-north-1.amazonaws.com/1730731585593_lvpfnugwgoa","createdAt":"2024-11-04T14:46:28.066Z","heading":"What is a Promise?","reactions":[],"status":"published","tag":"JavaScript","updatedAt":"2024-11-09T05:21:12.915Z"},"1":{"__v":0,"_id":"6728abf41aec9bbaf4acfbf8","author_id":{"_id":"6719d873a7ce679095b76e01","image":"https://res.cloudinary.com/djfhotv8n/image/upload/v1729747676/Escribir_Profile_Images/ybc9vtwqaqnly2lkwjhu.jpg","username":"Sneha K"},"comments":[],"content":"<h2>Peace Starts When We Embrace Who We Are, Not Who We Should Be</h2><p><img src=\"https://cdn-images-1.readmedium.com/v2/resize:fit:800/1*3Vuj3LOBgHyrDZjmkU4Dig.png\">Image created by author using&nbsp;<a href=\"https://www.midjourney.com/app/\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: inherit;\">MidJourney</a></p><p><br></p><p><br></p><p><em>“You’re doing better than you think. Stop being so hard on yourself,”</em>&nbsp;I told my friend as he sat across from me, tears streaming down his face. His voice cracked as he repeated the words:&nbsp;<em>“I failed her. I’m not good enough. I’ll never be good enough.”&nbsp;</em>I didn’t know what else to say to him. Here was someone who had never truly accepted himself, no matter how much he accomplished.</p><p>My friend had built a multimillion-dollar business from nothing, rising out of poverty. He cared for his aging parents, sent two siblings to college, and even helped them get married — all before he turned forty. Yet, despite these incredible achievements, his response was always the same whenever I praised him:&nbsp;<em>“Not good enough. Not yet.”</em></p><p>I know this mindset well, having grown up in an entrepreneurial family where my performance was constantly measured through comparisons.<em>“Look at so-and-so’s son and how well he’s doing,”</em>&nbsp;my father would say. That sense of comparisons and expectations was relentless. The thought of meeting these standards blinded me to the 90% of things I was doing right. Instead, I became fixated on the never-ending 10% I hadn’t achieved to prove myself, and if not, I would become bitter toward myself and those I was trying to match in performance. I would develop an inflated self-confidence that I would crush all aspects of business or have zero to no confidence in certain business activities.</p><p>When I didn’t feel competitive enough, I lost opportunities and friendships when there was a better approach for collaboration and a win-win. I often didn’t know why I was competing; I just wanted to prove to my father that I was better than the other guy, and he was wrong. Initially, things might feel like you are improving and moving forward. Still, the amount of poison and negative energy you inject into yourself is much more damaging than the instant pleasure of the wins. At last, my father realized he was doing more damage than good when, during a fight, I told him, “How about you adopt one of those guys as your son, and I will find myself a better father?” It was a shock to him but a natural response from my side, being drained and always trying to follow his ideal image of the perfect son.</p><p>I have realized that one of our biggest mistakes when we don’t value ourselves is that we tie our self-worth to specific goals, metrics, or others’ constant demands and expectations. When we do that, falling short makes us feel worthless. We see ourselves as either winners or losers, with no middle ground. I had been there for a long time, and it took me countless reflections to understand that It’s tough to break free from this negative cycle unless I completely realize that my circumstances shaped my life. We all have our strengths and weaknesses and can control only so much.</p><p>My friend’s heartbreak wasn’t just about the end of his relationship; it was the overwhelming pressure he had placed on himself to be perfect in every part of his life. His girlfriend left because he was sometimes too focused on his business, not always free or mentally ready for her constant desire to hang out at social events with her friends. While he blamed himself, I knew he had always done his best given the circumstances.&nbsp;<em>“What more could you expect from yourself?”</em>&nbsp;I asked him.&nbsp;<em>“How else could you have acted within your conditions? Come on, man, at least give yourself credit for doing your best.”</em></p><p>His situation reminded me of my own struggles with self-acceptance. It took me a great deal of time to realize that self-acceptance doesn’t mean we must agree with everything we’ve done or be happy with every outcome. It simply means recognizing our efforts and staying true to ourselves. His girlfriend compared him to her friend’s boyfriends, men who might have far fewer responsibilities. Was that fair? Maybe not. He might not have been the perfect boyfriend, but he was doing his best with what life threw at him.</p><p>Through tears running down his face, he told me that night,&nbsp;<em>“I’m so tired. I don’t know what I did wrong. I gave everything I had. I don’t even know who I am anymore. Every day, I wake up trying to meet everyone’s expectations, and by the end of the day, I break into bed, exhausted. Yet, no matter what I do or how much I ‘fix’ myself, I still feel like I’m not good enough unless I meet their standards.”</em></p><p>“<em>That’s because you’re expecting happiness through changing your core to satisfy others,</em>” I told him. “<em>And no one can keep going with that for too long.</em>”</p><p>That conversation taught me a lesson I will never forget: the constant “go, go, go” mentality—the relentless craving to make everyone happy—comes at the cost of living in the present. We’re always chasing an idealized future of ourselves that never brings real happiness. We are constantly walking toward a mirage, only to find emptiness when we arrive, with a sign telling us to continue until we’re drained and broken by exhaustion.</p><p>In the past, I’ve also confused personal growth with self-acceptance, which has driven me to exhaustion in the name of “endless progress.” It’s natural to want more and to grow, but real change only happens when we acknowledge who we are despite the expectations of others or an ideal image of ourselves. Change can’t come from denying ourselves—denial leads to self-destruction. It traps us in a cycle of dwelling on past mistakes and constantly questioning our worth whenever we fall short of someone else’s standards.</p><p>At that conversation, I wished my friend could accept himself; I wish he didn’t blame himself for his past, and I wish he could live in the present and trust that despite his painful experiences, he could still grow and evolve in future relationships. Yes, his girlfriend might be wonderful, and he might be short on delivering sometimes, but maybe she wasn’t the right person for him at that point, which he realizes today.</p><p>Gladly, now he has changed his approach. Instead of trying to change himself entirely for someone, he is very open and transparent about his circumstances when he goes out on a date. It’s much happier to be honest and true to ourselves and find those who match and accept our circumstances than to change our cores to attract or maintain someone who is unwilling to see the committed part in us.</p><p><img src=\"https://cdn-images-1.readmedium.com/v2/resize:fit:800/1*-e_-zcnK0faNwbvMQonFCA.png\">Image created by author using&nbsp;<a href=\"https://www.midjourney.com/app/\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: inherit;\">MidJourney</a></p><p><br></p><p><br></p><p>Self-acceptance is difficult for many because it takes tremendous courage to be brutally honest with ourselves. It requires us to look at who we are without denial or avoidance. When we see the parts of ourselves that don’t measure up to someone else’s standards, we must also recognize the good in us — the beautiful qualities and positive force that contribute to the lives of others. That’s not easy when everyone holds you to expectations that make you feel unworthy the moment you fall short.</p><p>We all need to understand that individually we are whole beings, and collectively we paint the whole picture. You are not just a collection of good and bad parts — you are a complete person. You have strengths in certain areas, and the people you choose in life should complement you just as you complement them.</p><p>When you accept yourself and allow yourself to grow into your best form, you’ll realize that you only need to meet your natural and basic expectations, not anyone else’s. That’s when you begin to live authentically and give others the space to grow into their best selves within their abilities and circumstances.</p><p>That night, I told my friend, “<em>You don’t need all the answers right now, and that’s okay. Just understand that this is who you are, and this is your situation. Be at peace with that and move forward from there. The end of your relationship doesn’t mean you’re unlovable or incapable of giving love.</em>” I wasn’t asking him to ignore the pain or pretend nothing happened, but to acknowledge it without letting it define him. I encouraged him to see himself not as someone who failed but as someone who tried, learned, and is still standing despite it all, and today, he is finding more joy in his dating life.</p><p><br></p><p>One important lesson I’ve learned from painful experiences is to avoid comparing myself to others or being compared to anyone at any cost. I understand that life can be competitive, but comparison is not the right approach to growth. It’s the enemy of self-acceptance, breeding feelings of inadequacy. When we compare ourselves, we might create slightly better versions than others, but it comes at the expense of our authenticity. It traps us in a cycle of feeling worthless, never enough, and incapable. When we learn to see our authentic beauty, we also begin to see it in others without neglecting our self-worth. Others can inspire us, but we don’t need to become a copy of someone else in the name of improvement or to meet the demands of others.</p><p>Life teaches us that nature thrives in diversity. Each of its creations grows according to its strengths and circumstances. Denying the best in ourselves is denying the gifts life has given us. An oak tree doesn’t strive to become a smaller banana tree or a much larger mountain. It grows into its most natural and beautiful form, providing shade and strength for those who need it. That’s the essence of self-acceptance: it’s to become the best version of yourself, free from comparison. When you truly embrace that, everything else follows naturally.<strong>&nbsp;Cheers!</strong></p><p><br></p>","coverImageUrl":"https://escribir.s3.eu-north-1.amazonaws.com/1730718702669_aww8gabts9h","createdAt":"2024-11-04T11:11:48.729Z","heading":"When You Accept Yourself, Everything Else Falls Into Place","reactions":[],"status":"published","tag":"Self-Motivation","updatedAt":"2024-11-04T11:11:48.729Z"},"2":{"__v":0,"_id":"6728aaee1aec9bbaf4acfbe6","author_id":{"_id":"6719d873a7ce679095b76e01","image":"https://res.cloudinary.com/djfhotv8n/image/upload/v1729747676/Escribir_Profile_Images/ybc9vtwqaqnly2lkwjhu.jpg","username":"Sneha K"},"comments":[],"content":"<h2><br></h2><h1><br></h1><h1>How slowing down helped me move from burnout to clarity and finally discover the meaning behind my work and life</h1><h1><br></h1><p><img src=\"https://cdn-images-1.readmedium.com/v2/resize:fit:800/1*KGZwmYeby0MYf8E3pWnntA.png\">Image created by author using&nbsp;<a href=\"https://www.midjourney.com/app/\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: inherit;\">MidJourney</a></p><p><br></p><p><br></p><p><em>“I can’t stop! If I do, I’ll lose momentum, and everything I’ve built will fall apart!”</em>&nbsp;I replied in frustration.</p><p>My friend stared at me in confusion and said,&nbsp;<em>“What’s the point of it all if you’re the one falling apart?”</em></p><p><br></p><p><em><span class=\"ql-cursor\">﻿</span></em></p><p><strong>I froze. I had no answer!</strong></p><p>A few years ago, I believed that worthy accomplishment was defined by non-stop action. I thought the harder I pushed, the closer I’d get to the finish line of success. I assumed if I filled every second of my day with tasks and deadlines, I’d look and feel busy, and my goals would be achieved on autopilot.</p><p>But, in truth, I was driven by fear of falling behind. I was insecure and terrified of appearing lazy or like a procrastinator. I lived in megacities where more work was glorified, and constant busyness was a badge of discipline and focus. The problem was that the more I convinced myself I was doing the right thing, the more disconnected I became from myself. My behavior was making me less productive and even more ineffective. I spent time doing things but saw little to no noticeable return.</p><p>Looking back, I realize I left no room for reflection, no space to question whether I was doing things right. Pausing isn’t laziness; it’s wisdom. Stepping back from the noise and constant movement allows us to create space for clarity, reflection, and meaningful progress.</p><p>I often worked on projects for over 48 hours straight, with little to no sleep, forgetting and dismissing eating or even hydrating myself well. If you looked at my face, you’d see red eyes surrounded by dark circles — a zombie drained of energy. Like many of us, I, too, felt like everyone else was moving faster, and I couldn’t afford to stop. Pausing, to me, meant failure. I wish I’d known then that true success isn’t about how busy we are but about the intention behind our actions and the meaning behind our goals.</p><p>How many of us assume busyness gives us purpose? In reality, it steals our joy and clarity. We’re constantly driven by the need to prove ourselves, but in that pursuit, we forget that our well-being and happiness matter the most. When we don’t pause, breathe, and reflect, we never allow ourselves to realign with what truly matters. True accomplishment isn’t about how much we push — it’s about understanding when to take a step back and preventing ourselves from pushing too far into exhaustion</p><p>My attitude didn’t bring me the success I wanted. It led me to anxiety and depression. I became physically exhausted, mentally drained, and emotionally numb. Day after day, I watched my design proposals slip away to competitors who invested less effort but more “<strong>thoughtfulness</strong>.”</p><p>Mental health is a serious matter, and it made me stop. I was drained of energy and lacked motivation, even for the smallest tasks. My friends didn’t understand the situation and encouraged me to ignore my feelings and press on, but the harder I pushed, the more my mind and body fought back.</p><p>One night, I lost a design proposal I had spent so many days on and smashed my MacBook Pro against the wall. My ex-wife thought I was angry, but the underlying truth was I was desperate. I was hungry for success, yet my efforts yielded nothing. I listened to endless motivational videos to encourage myself, but practicality said otherwise.</p><p>The problem with the go-go-go mentality is that it fosters a scarcity mindset — do it now, or it’ll never happen. The truth is that opportunities will always exist, and we can achieve success if we slow down and think through our intentions.</p><p>My teacher in Shanghai, a wise, practical, and successful man in his 50s, captured this perfectly. One day, he told me, “<em>Maybe you are doing the right thing, but perhaps you are not doing it right. Learn to pause, move in small steps, and protect your well-being. Once you’re exhausted, it’s game over. People who aim to win know how to play longer while feeling their best.”</em></p><p>What he said was deep and true, many of us pursue the right goals, but our approach might be wrong. We put our relationships, mental health, and physical well-being at risk in the hope of achieving a future success that, to be honest, is unpredictable. We rush through everything and end up with nothing but exhaustion.</p><p>When we lose confidence, we think we’re not good enough for the job, when in reality, all we needed were moments of stillness to reflect and refill our energy. That’s why so many lose faith in themselves despite having the strength and talent to achieve their goals — if only they slowed down, contemplated, and took one small step at a time.</p><p>Burnout doesn’t happen overnight. I’ve experienced it countless times in my life. When we push ourselves beyond our limits, exhaustion becomes unavoidable. Once it takes hold, we lose clarity and purpose. What once felt meaningful becomes draining. Burnout is our spirit’s way of demanding that we need to stop.</p><p>At first, the idea of pausing and taking a step back was impossible to accept. It was completely uncomfortable because I thought I’d lose grip. It’s interesting when the brain is hooked on believing that more work equals greatness and rejects the thought of stepping away. The idea of turning off my computer, sitting on my balcony, or walking in the park without listening to a productivity book felt like proof of laziness.</p><p>What I forgot was that hardcore motivational talk is easy to say but, at times, impractical to follow. We’re human and vary in our energy levels, hormones, and emotions. There is a limit to how much we can push. I learned through experience that no matter how much guilt rushes through our minds, reminding us of what we “<strong>should</strong>” be doing, we’ll never feel like we’re doing enough — it’s human nature to want to achieve more and more.</p><p>But we forget that, at some point, our bodies will tire and push back. That’s when we have to stop, listen to our bodies, and root our sense of accomplishment in reality. Because even if we achieve materialistic success, without inner peace and moments of true relaxation, our lives will start to feel unbalanced, and the motivation and meaning we once had may begin to fade.</p><p><img src=\"https://cdn-images-1.readmedium.com/v2/resize:fit:800/1*qkct7UqT5UTJTTlpNo6YDg.png\">Image created by author using&nbsp;<a href=\"https://www.midjourney.com/app/\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: inherit;\">MidJourney</a></p><p><br></p><p><br></p><p>My first conscious step back happened when I left my phone at home and went for a walk in the park for an hour. At first, I was worried about missing messages. But then I paused and asked myself,<em>&nbsp;“What is wrong with you? You’ve been working non-stop for years, and you’ve gotten nowhere near your goals. Why do you think this one hour will make any difference?”</em></p><p>I realized I was looking busy all the time, but I wasn’t productive. I was just stuck behind my screen, eyeballs tracking the curser. When I assured myself that nothing would happen in that hour, I shifted my attention from the constant noise in my head urging me to keep overthinking about my work to the beauty of the world around me.</p><p>I noticed an elderly man who had brought a chicken to the park, letting kids play with it. Some cats in the park stared at the chicken, and a few even tried to chase it, but the man kept shooing them away. It was a joyful moment, and people laughed as they watched. The scene made me appreciate the beauty and vibrancy of the world around me, filling me with a sense of joy.</p><p>As I walked through the park, I felt the warmth of the sunlight, the breeze of fresh air, and the scent of beautiful Gardenia flowers. The tension in my muscles and the fogginess in my mind began to fade. My chest felt lighter, my breath deeper, and my thoughts clearer.</p><p>Many of us struggle with the silence that comes with stillness, but in these moments, we confront the truths buried under the weight of busyness. Learning to pause, even for small moments, helps us release what no longer serves us and discover a deeper sense of purpose. Clarity doesn’t come from doing more but from stepping back and creating space to think mindfully.</p><p>Pausing and reflecting have now become part of my daily routine. Whenever I feel myself rushing into work, I remind myself that this path only leads to burnout and exhaustion.</p><p>Sometimes, I call a friend and escape to a coffee shop or arcade for some lighthearted fun, stepping away from the constant pressure of work. These moments are important; they give me a much-needed break and allow my mind to reset.</p><p>During these moments of relaxation, I take the time to ask myself, What do I truly want? Why am I doing this? With greater clarity, I approach my work with intention, recognizing that if I’m not enjoying what I’m doing, it may not align with my passions. This realization often leads me to consider letting go of what no longer serves me and seeking out opportunities that better reflect my values. Once refreshed, I return feeling rejuvenated and ready to tackle my tasks with renewed energy.</p><p>There is a quote by John Lennon, “The time you enjoy wasting is not wasted time.” This quote resonates because pausing brings real value to our lives and is a wise use of time; it allows us to relax and act with intention, leading to more meaningful outcomes.</p><p>On the other hand, staying busy for the sake of it or rushing through projects without taking a moment to reflect on our goals and actions wastes both time and energy, often resulting in unclear aims and inefficient efforts. Pausing doesn’t mean losing momentum; it means gaining clarity and avoiding unnecessary mistakes. It allows us to approach tasks with a refreshed perspective, often leading to insights we might miss if we’re always in motion.</p><p>This change in my mindset has greatly helped me guide others toward clearer thinking as well. In my consulting business, when I see clients rushing, I urge them to slow down because, without thoughtfulness, we risk producing ineffective work that may need to be redone later. When they slow down and take the time to think about their decisions and actions, they approach tasks with more intention and ultimately appreciate the results of their careful investments — whether of time, effort, or money.</p><p><img src=\"https://cdn-images-1.readmedium.com/v2/resize:fit:800/1*IGU-4m4waL-tcb837JlbwQ.png\">Image created by author using&nbsp;<a href=\"https://www.midjourney.com/app/\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: inherit;\">MidJourney</a></p><p><br></p><p>This mindset adds “<strong>quality”</strong>&nbsp;to our lives — a concept we need to learn to embrace if we seek personal improvement. When we prioritize our mental, emotional, and physical health, everything else aligns harmoniously, allowing us to pursue our goals purposefully.</p><p>The world often demands continuous action, whether from work, relationships, or other commitments. When we fail to pause and recharge, it leads to burnout. Pausing shifts our focus from solely completing tasks to being present, allowing us to reflect on what truly matters in our lives. It allows us to consider our priorities and the relationships we value the most.</p><p>Next time you feel like you can’t stop, take a deep breath and&nbsp;<strong>ask yourself:&nbsp;</strong>What’s more important — blindly pushing forward or stepping back to find clarity? Are you moving with purpose or just keeping up with the pace? When we aim for peace, growth follows. Clarity emerges when you take a step back and trust that intention drives progress.&nbsp;<strong>Reflect on this:&nbsp;</strong>When given the choice, wouldn’t you prefer clarity over chaos? Here’s to choosing with intention.&nbsp;<strong>Cheers!</strong></p><p><br></p>","coverImageUrl":"https://escribir.s3.eu-north-1.amazonaws.com/1730718444147_v2tldzczzqq","createdAt":"2024-11-04T11:07:26.282Z","heading":"When You Pause, Your True Purpose Reveals Itself","reactions":[],"status":"published","tag":"Self-Motivation","updatedAt":"2024-11-04T11:07:26.282Z"},"3":{"__v":0,"_id":"6728a6761aec9bbaf4acfbd5","author_id":{"_id":"66ebecd0eb53f2be6b08101d","image":"https://res.cloudinary.com/djfhotv8n/image/upload/v1729616317/Escribir_Profile_Images/m4liuexkuts6xr6bdngp.jpg","username":"Jansiya jahan"},"comments":[],"content":"<h3><strong>Visual representations</strong></h3><p>I think it’s always good to start with some visualization.</p><p>Here are the most common pictures of this concept.</p><p><img src=\"https://cdn-media-1.freecodecamp.org/images/oVVbTLR5gXHgP8Ehlz1qzRm5LLjX9kv2Zri6\" alt=\"Image\" height=\"567\" width=\"772\"></p><p><img src=\"https://cdn-media-1.freecodecamp.org/images/YsN6twE3-4Q4OYpgxoModmx29I8zthQ3f0OR\" alt=\"Image\" height=\"400\" width=\"600\">_Source and credit: [https://www.codingblocks.net/podcast/clean-architecture-make-your-architecture-scream/](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html\" rel=\"noopener\" target=\"_blank\" title=\"\"&gt;https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html .&lt;a href=\"https://www.codingblocks.net/podcast/clean-architecture-make-your-architecture-scream/\" rel=\"noopener\" target=\"<em style=\"color: var(--gray85);\">blank\" title=\")</em></p><p><img src=\"https://cdn-media-1.freecodecamp.org/images/lbexLhWvRfpexSV0lSIWczkHd5KdszeDy9a3\" alt=\"Image\" height=\"400\" width=\"600\"></p><p><img src=\"https://cdn-media-1.freecodecamp.org/images/YIABVRTHRz58ZiT6W-emBkfNIQUHBelp8t6U\" alt=\"Image\" height=\"400\" width=\"600\">_Source and credit: Mattia Battiston, under CC BY 4.0, [https://github.com/mattia-battiston/clean-architecture-example](https://github.com/mattia-battiston/clean-architecture-example\" rel=\"noopener\" target=\"<em style=\"color: var(--gray85);\">blank\" title=\")</em></p><p><img src=\"https://cdn-media-1.freecodecamp.org/images/TmSQbZOg5bxn0cRXxIrRUd2zhqeDAXTe8ni5\" alt=\"Image\" height=\"400\" width=\"600\">_Source and credit: [https://marconijr.com/posts/clean-architecture-practice/](https://marconijr.com/posts/clean-architecture-practice/\" rel=\"noopener\" target=\"<em style=\"color: var(--gray85);\">blank\" title=\")</em></p><h3><strong>The concept — presented in bullet points</strong></h3><p>Extended from Source and credit:&nbsp;<a href=\"https://github.com/mattia-battiston/clean-architecture-example\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: var(--gray90); background-color: transparent;\">Mattia Battiston, under CC BY 4.0</a></p><h4><strong>The value it can provide</strong></h4><ul><li>An effective testing strategy that follows the testing pyramid</li><li>Frameworks are isolated in individual modules. When (not if) we change our mind, we only have to make a change in one place. The app has use cases rather than being tied to a CRUD system</li><li>Screaming architecture a.k.a. it screams its intended usage. When you look at the package structure, you get a feel for what the application does rather than seeing technical details</li><li>All business logic is in a use case, so it’s easy to find and not duplicated anywhere else</li><li>Hard to do the wrong thing because modules enforce compilation dependencies. If you try to use something that you’re not meant to, the app doesn’t compile</li><li>It is always ready to deploy by leaving the wiring up of the object for last. Or by using feature flags, so we get all the benefits of continuous integration</li><li>Multiple works on stories so that different pairs can easily work on the same story at the same time to complete it quicker</li><li>Good monolith with clear use cases that you can split in microservices later on, once you’ve learned more about them</li></ul><h4><strong>Entities</strong></h4><ul><li>Represent your domain object</li><li>Apply only logic that is applicable in general to the whole entity (e.g., validating the format of a hostname)</li><li>Plain objects: no frameworks, no annotations</li></ul><h4><strong>Use Cases</strong></h4><ul><li>Represent your business actions: it’s what you can do with the application. Expect one use case for each business action</li><li>Pure business logic, plain code (except maybe some utils libraries)</li><li>The use case doesn’t know who triggered it and how the results are going to be presented (for example, could be on a web page, or — returned as JSON, or simply logged, and so on.)</li><li>Throws business exceptions</li></ul><h4><strong>Interfaces / Adapters</strong></h4><ul><li>Retrieve and store data from and to a number of sources (database, network devices, file system, 3rd parties, and so on.)</li><li>Define interfaces for the data that they need in order to apply some logic. One or more data providers will implement the interface, but the use case doesn’t know where the data is coming from</li><li>Implement the interfaces defined by the use case</li><li>There are ways to interact with the application, and typically involve a delivery mechanism (for example, REST APIs, scheduled jobs, GUI, other systems)</li><li>Trigger a use case and convert the result to the appropriate format for the delivery mechanism</li><li>the controller for a MVC</li></ul><h4><strong>External Interfaces</strong></h4><ul><li>Use whatever framework is most appropriate (they are going to be isolated here anyway)</li></ul><h3><strong>Code example</strong></h3><p>See the structure on&nbsp;<a href=\"https://github.com/Createdd/web-miner/tree/master/webminer\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: var(--gray90); background-color: transparent;\">GitHub</a>.</p><p>First of all, it is important to understand that clean architecture is a bundle of organising principles. So therefore everything is open to personal adjustments as long as core ideas are kept intact. The linked repository is a fork of the original project that brought this architecture design idea to me. Feel free to check out the original project as well, as it reflects further improvements.</p><p>The webminer folder is structured into the basic layers:</p><ol><li>entities</li><li>use_cases</li><li>interfaces_adapters</li><li>external_interfaces</li></ol><p><img src=\"https://cdn-media-1.freecodecamp.org/images/FSvBm5GdWA0uMo6NJhyOoF2hgJt8s1Bv3n1v\" alt=\"Image\" height=\"400\" width=\"600\"><em style=\"color: var(--gray85);\">Structure of the webminer folder</em></p><p>It shall reflect the very basic approach for the design pattern.</p><ul><li>Starting from&nbsp;<code>entities</code>, you can see that the core model of this project is the&nbsp;<code>arxiv_document</code></li><li>The next folder,&nbsp;<code>use_cases</code>&nbsp;shows our use case, namely to request the arxiv page</li><li>After that, we go through the&nbsp;<code>interface_adapters</code>&nbsp;folder that provides adapters for process requests in a REST application or for serializing</li><li>The final and last layer is&nbsp;<code>external_interfaces</code>. This is where we use the flask server to implement the REST functionality</li></ul><p>All of those layers are dependent on the core layers but not the other way around.</p><p><strong style=\"color: var(--gray85);\">One important note: This is not 100% correctly implemented in the repository.</strong></p><p>Why? Because the use cases are actually different. In reality the main use case is to provide the structured data. Another use case is to get the data from the arxiv page.</p><p>Did you spot this error in the architecture? If yes, congratulations! Not only did you bring enough curiosity to this article but you likely understand the principles well enough to build your own case and apply the concepts in reality!</p><p>Do you agree? If not, why? Thanks for reading my article! Feel free to leave any feedback!</p>","coverImageUrl":"https://escribir.s3.eu-north-1.amazonaws.com/1730717299890_5yzadkrd3l5","createdAt":"2024-11-04T10:48:22.122Z","heading":"A quick introduction to clean architecture","reactions":[],"status":"published","tag":"JavaScript","updatedAt":"2024-11-04T10:48:22.122Z"},"4":{"__v":0,"_id":"6728a6291aec9bbaf4acfbcd","author_id":{"_id":"66ebecd0eb53f2be6b08101d","image":"https://res.cloudinary.com/djfhotv8n/image/upload/v1729616317/Escribir_Profile_Images/m4liuexkuts6xr6bdngp.jpg","username":"Jansiya jahan"},"comments":[],"content":"<p><span style=\"color: rgb(36, 36, 36);\">TypeScript is an open-source programming language developed by Microsoft. It is a statically typed superset of JavaScript, which means that any valid JavaScript code is also valid TypeScript code. However, TypeScript adds optional static typing and other features to help developers write more scalable and maintainable code. TypeScript and JavaScript are like brothers. As you know JavaScript was made in year of 1995 only in ten days it show how hurriedly in urgency they made this language so it have so many errors but now after so many upgrades its good to go. but now we have TypeScript which is more tackle-able as compared to JavaScript so in TypeScript</span></p><p><br></p><ul><li><span class=\"ql-cursor\">﻿</span>TypeScript&nbsp;<a href=\"https://www.youtube.com/redirect?event=video_description&amp;redir_token=QUFFLUhqbFFvT1ZkSnVYUllvZ0JPZTg5b2FmbkRBN3lOd3xBQ3Jtc0tubXkxQWo1SjNoelFjSTk4dnZvMXlkTEVNamp3WDNPYTlURzBfSXZXS2RtMmJHRmp0S2dLaHNjS25nVUFuNVlWdFdMWk1EUU1DQXBRVldTb3JWTk9Uc1lRcElkRmxpckZHVFgwYnFZWHducDdwNEdlMA&amp;q=https%3A%2F%2Fwww.typescriptlang.org%2Fdownload&amp;v=f3xeJOvqUPQ\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: inherit;\">https://www.typescriptlang.org/download</a></li></ul><p><br></p><p><span style=\"color: rgb(36, 36, 36);\"><img src=\"https://miro.medium.com/v2/resize:fit:708/1*-GCUmL0FbFSpT2SLa74P4Q.png\" alt=\"https://www.typescriptlang.org/download\" height=\"215\" width=\"566\"></span></p><p><span style=\"color: rgb(36, 36, 36);\">So here’s a breakdown of some key concepts in TypeScript:</span></p><ul><li>Static Typing: TypeScript allows you to specify types for variables, function parameters, return types, and more. This helps catch type-related errors during development and provides better tooling support for code editors.</li><li>Type Inference: TypeScript’s type inference system can often automatically infer types based on how you’ve written your code. This means you don’t always have to explicitly specify types, though you can if you want to be more explicit.</li><li>Interfaces and Types: TypeScript allows you to define custom types using interfaces and types. These can describe the shape of objects, including the types of their properties and methods.</li><li>Classes and Inheritance: TypeScript supports object-oriented programming features like classes, inheritance, and access modifiers (public, private, and protected).</li><li>Enums: TypeScript provides support for enums, which allow you to define a set of named constants. Enums are useful when you have a fixed set of values that a variable can take.</li><li>Generics: TypeScript supports generics, which allow you to write reusable code that can work with a variety of data types while still maintaining type safety.</li><li>Modules: TypeScript supports modular programming through the use of modules. You can import and export functionality between different files, which helps organize code and manage dependencies.</li></ul><p>Overall, TypeScript aims to make it easier to build large-scale JavaScript applications by adding features that help catch errors early, improve code maintainability, and provide better tooling support. It compiles down to plain JavaScript, through node.js it works as a compiler in between JS &amp; TS so it easily run on any JavaScript runtime, making it a versatile choice for web development.<span style=\"color: rgb(36, 36, 36);\">&nbsp;</span></p>","coverImageUrl":"https://escribir.s3.eu-north-1.amazonaws.com/1730717223118_5njbdoap6ps","createdAt":"2024-11-04T10:47:05.763Z","heading":"Introduction To TypeScript","reactions":[],"status":"published","tag":"TypeScript","updatedAt":"2024-11-04T10:47:05.763Z"},"5":{"__v":0,"_id":"67288d201aec9bbaf4acfb11","author_id":{"_id":"66ebecd0eb53f2be6b08101d","image":"https://res.cloudinary.com/djfhotv8n/image/upload/v1729616317/Escribir_Profile_Images/m4liuexkuts6xr6bdngp.jpg","username":"Jansiya jahan"},"comments":[],"content":"<p><img src=\"https://miro.medium.com/v2/resize:fit:875/0*kCfge4a9Xm0zyqcP\" height=\"394\" width=\"700\"></p><p><strong>First lets Define what WebRTC is</strong></p><p>WebRTC is a set of JavaScript API’s that allow us to establish a peer to peer connection between two browsers to exchange data such as audio and video, allowing us to create applications with audio and video calling features.</p><p>What makes WebRTC special is that once a connection is established; data can be transmitted directly between browsers in real time without touching the server.&nbsp;By bypassing the server we reduce latency since the data doesn’t have to go to the server first, this makes webRTC great for exchanging audio and video.</p><p>Full video tutorial: “<a href=\"https://youtu.be/8I2axE6j204\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: inherit;\">How Does WebRTC Work? | Crash Course</a>”</p><p><strong>WebRTC Vs WebSockets</strong></p><p>Before we talk about how all this works, let’s look at the comparison between WebRTC and WebSockets since I know a lot of you are thinking “this sounds a lot like WebSockets, so why do we need WebRTC?” or vice versa.</p><p><img src=\"https://miro.medium.com/v2/resize:fit:875/0*Own87NQd76MSw2hc\" height=\"308\" width=\"700\"></p><p>With websockets we can also establish a connection between peers to exchange data in real time, but this connection is between the client and server. So if I send a message to a peer, the message first goes to the server, then the server sends that message to the other peer. This exchange typically happens really fast so even though there is some latency, you probably wouldn’t even notice it if you’re sending something like a chat message or some kind of notification.</p><p>Now let’s say we wanted to exchange some audio or video using websockets, after all this is possible.</p><p>The problem here is that even the slightest latency when it comes to audio and video can be very noticeable and causes a lot of issues. So by the time your video data hits the server and back to your peer, you’re gonna see a significant delay.</p><p>This is where webRTC makes sense. By establishing a connection and exchanging data between two browsers we eliminate any delay that the server may add. WebRTC also uses User Datagram Protocol, or UDP, which is great for transmitting data really fast but more on that in a moment.</p><p><strong>So if webRTC is so fast, why use websockets at all?</strong></p><p>There are certain limitations with webRTC so typically using webRTC with websockets is more of a common practice.</p><p>First, webRTC uses UDP, and UDP is not a reliable protocol for transferring important data. UDP is good at sending data really fast but it doesn’t check whether or not the data is being received. So UDP is great for video because the data gets there fast and if we lose a few frames it’s not a big deal; but if this were a file we needed to send over and we lose a few bytes of data the entire file can be corrupted.</p><p>WebRTC also has no built-in signaling so it cant be used on its own to establish a peer to peer connection. WebRTC takes care of everything for us once the connection is established but leaves it up to us on how to transmit the initial data in order to connect two peers.</p><p><strong>So how does all of this work?</strong></p><p><img src=\"https://miro.medium.com/v2/resize:fit:875/0*8CIZHw7jhUcAqM96\" height=\"394\" width=\"700\"></p><p>From a high level perspective, to establish a connection, peer 1 will send some kind of message to peer 2 saying “hey, I want to connect to you, here’s some information about me and how you can connect to me, do you accept my offer?”</p><p>How this message is sent is irrelevant. This could be an email, a tweet OR you can signal it over to peer 2, it doesn’t matter, that parts up to you.</p><p>When peer 2 gets this information from peer 1, they have the opportunity to accept the connection. If peer 2 accepts, they will gather some information about their network and how to connect to it, and then send this information back to peer 1.</p><p>Once both peers have eachothers information, they are now connected and can now begin exchanging audio and video data or whatever else they want to send directly between their browsers without needing the server anymore.</p><p><strong>So what exactly is sent between the two clients and how is it sent?</strong></p><p>First off, how the information is sent is usually through a process called signaling. Since the two peers don’t know about each other we would typically have a way to bring them into a channel together using something like WebSockets or any third party signaling services.</p><p>Once we bring them into the same channel or room, they can now signal over their connection details. Those connection details come in the form of a session description protocol (SDP) and ICE candidates.</p><blockquote><strong><em>SDP&nbsp;</em></strong><em>— A Session Description Protocol (SDP), is an object containing information about the session connection such as the codec, address, media type, audio and video and so on. Both peers will exchange SDP’s so they can understand how to connect to each other. One in the form of an</em><strong><em>&nbsp;</em></strong><em>SDP Offer and another as an SDP Answer</em><strong><em>.</em></strong></blockquote><blockquote><strong><em>Ice Candidates</em></strong><em>&nbsp;— An ICE candidate is a public IP address and port that could potentially be an address that receives data. Each user will typically have multiple Ice candidates that are gathered by making a series of requests to a STUN server.</em></blockquote><p>Exchanging Session Description Protocols and ICE candidates</p><p><img src=\"https://miro.medium.com/v2/resize:fit:875/0*cVujHaI_uJlRKGbZ\" height=\"394\" width=\"700\"></p><p><strong>So here is the order in which things will play out.</strong></p><p>First the two peers will exchange SDP’s using some sort of signaling method. Once the two SDP’s are exchanged the peers are now connected, but still CANNOT transmit data yet.</p><p>In order to exchange data between two peers we still need to transmit the data.The problem here is that nowadays most devices sit behind firewalls and NAT devices, so to coordinate the discovery of our public IP addresses we use a method called ICE, which stands for Interactive Connectivity Establishment.</p><p>So in the background once SDP offers are exchanged each peer will then make a series of requests to a STUN server which will generate a list of ICE candidates to use. STUN servers are cheap and easy to maintain and because of that there are tons of free services you can use so you won’t have to worry about setting one up.</p><p>Once peer 1 gets these ICE candidates back from the STUN they will send them over to peer 2 and will let the network determine the best candidate to use. Peer 2 will do the same by requesting their ICE candidates and then sending them to peer 1.</p><p>When these candidates are exchanged and an optimal path is discovered data can begin to flow between the two peers.</p><p><strong>Trickling ICE Candidates</strong></p><p>There’s one problem with the process of retrieving ice candidates and that is that it can take time. So for this we commonly use a method called “Trickle ICE” which means that as we receive each ICE candidate from the STUN server we will simply send them over one by one, so they will “trickle in”.</p><p><strong>Seeing it in action</strong></p><p>I put together a live demo so you can see how the SDP transfer process works without a signaling server. With this live demo you’ll open two tabs side by side and create, then transfer and SDP offer and answer between two peers. We won’t have to deal with Trickling on ICE candidates since they will be added to the SDP offer on creation.</p>","coverImageUrl":"https://escribir.s3.eu-north-1.amazonaws.com/1730710814257_c13u3ik81i8","createdAt":"2024-11-04T09:00:16.666Z","heading":"How does WebRTC work?","reactions":[],"status":"published","tag":"WebSocket","updatedAt":"2024-11-04T09:00:16.666Z"},"level":"info","message":"Blogs fetched:","timestamp":"2024-11-20T10:37:18.689Z"}
{"level":"info","message":"Fetching all blogs","timestamp":"2024-11-20T10:41:19.634Z"}
{"level":"info","message":"Fetching all blogs","timestamp":"2024-11-20T10:41:19.868Z"}
